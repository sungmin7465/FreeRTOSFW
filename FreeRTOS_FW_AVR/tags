!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BASIC_IO_H	src/FreeRTOS_AVR/basic_io_avr.h	51;"	d
BaseType_t	src/FreeRTOS_AVR/utility/portmacro.h	/^typedef signed char BaseType_t;$/;"	t
CAL_FACTOR	src/FreeRTOS_AVR/FreeRTOS_AVR.c	27;"	d	file:
CO_ROUTINE_H	src/FreeRTOS_AVR/utility/croutine.h	71;"	d
CRCB_t	src/FreeRTOS_AVR/utility/croutine.h	/^} CRCB_t; \/* Co-routine control block.  Note must be identical in size down to uxPriority with TCB_t. *\/$/;"	t	typeref:struct:corCoRoutineControlBlock
CallbackParameters_t	src/FreeRTOS_AVR/utility/timers.c	/^} CallbackParameters_t;$/;"	t	typeref:struct:tmrCallbackParameters	file:
CoRoutineHandle_t	src/FreeRTOS_AVR/utility/croutine.h	/^typedef void * CoRoutineHandle_t;$/;"	t
DEPRECATED_DEFINITIONS_H	src/FreeRTOS_AVR/utility/deprecated_definitions.h	71;"	d
DaemonTaskMessage_t	src/FreeRTOS_AVR/utility/timers.c	/^} DaemonTaskMessage_t;$/;"	t	typeref:struct:tmrTimerQueueMessage	file:
EVENT_GROUPS_H	src/FreeRTOS_AVR/utility/event_groups.h	71;"	d
EventBits_t	src/FreeRTOS_AVR/utility/event_groups.h	/^typedef TickType_t EventBits_t;$/;"	t
EventGroupHandle_t	src/FreeRTOS_AVR/utility/event_groups.h	/^typedef void * EventGroupHandle_t;$/;"	t
EventGroup_t	src/FreeRTOS_AVR/utility/event_groups.c	/^} EventGroup_t;$/;"	t	typeref:struct:xEventGroupDefinition	file:
FHideParams	src/kmu_framework.h	/^} FHideParams;$/;"	t	typeref:struct:FxHideParams
FRAMEWORK_H	src/kmu_framework.h	12;"	d
FREERTOS_CONFIG_H	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	71;"	d
FREE_RTOS_AVR_VERSION	src/FreeRTOS_AVR/FreeRTOS_AVR.h	27;"	d
FReadyTask	src/kmu_framework.h	/^} FReadyTask;$/;"	t	typeref:struct:FxReadyTask
FreeRTOS_AVR_h	src/FreeRTOS_AVR/FreeRTOS_AVR.h	6;"	d
FxHideParams	src/kmu_framework.h	/^typedef struct FxHideParams {$/;"	s
FxReadyTask	src/kmu_framework.h	/^typedef struct FxReadyTask {$/;"	s
HeapRegion	src/FreeRTOS_AVR/utility/portable.h	/^typedef struct HeapRegion$/;"	s
HeapRegion_t	src/FreeRTOS_AVR/utility/portable.h	/^} HeapRegion_t;$/;"	t	typeref:struct:HeapRegion
INCLUDE_eTaskGetState	src/FreeRTOS_AVR/utility/FreeRTOS.h	207;"	d
INCLUDE_pcTaskGetTaskName	src/FreeRTOS_AVR/utility/FreeRTOS.h	191;"	d
INCLUDE_uxTaskGetStackHighWaterMark	src/FreeRTOS_AVR/utility/FreeRTOS.h	203;"	d
INCLUDE_uxTaskGetStackHighWaterMark	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	125;"	d
INCLUDE_uxTaskPriorityGet	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	116;"	d
INCLUDE_vTaskCleanUpResources	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	118;"	d
INCLUDE_vTaskDelay	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	121;"	d
INCLUDE_vTaskDelayUntil	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	120;"	d
INCLUDE_vTaskDelete	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	117;"	d
INCLUDE_vTaskPrioritySet	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	115;"	d
INCLUDE_vTaskSuspend	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	119;"	d
INCLUDE_xEventGroupSetBitFromISR	src/FreeRTOS_AVR/utility/FreeRTOS.h	251;"	d
INCLUDE_xQueueGetMutexHolder	src/FreeRTOS_AVR/utility/FreeRTOS.h	183;"	d
INCLUDE_xSemaphoreGetMutexHolder	src/FreeRTOS_AVR/utility/FreeRTOS.h	187;"	d
INCLUDE_xTaskGetCurrentTaskHandle	src/FreeRTOS_AVR/utility/FreeRTOS.h	287;"	d
INCLUDE_xTaskGetIdleTaskHandle	src/FreeRTOS_AVR/utility/FreeRTOS.h	175;"	d
INCLUDE_xTaskGetIdleTaskHandle	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	126;"	d
INCLUDE_xTaskGetSchedulerState	src/FreeRTOS_AVR/utility/FreeRTOS.h	283;"	d
INCLUDE_xTaskResumeFromISR	src/FreeRTOS_AVR/utility/FreeRTOS.h	247;"	d
INCLUDE_xTimerGetTimerDaemonTaskHandle	src/FreeRTOS_AVR/utility/FreeRTOS.h	179;"	d
INCLUDE_xTimerPendFunctionCall	src/FreeRTOS_AVR/utility/FreeRTOS.h	255;"	d
INC_FREERTOS_H	src/FreeRTOS_AVR/utility/FreeRTOS.h	71;"	d
INC_TASK_H	src/FreeRTOS_AVR/utility/task.h	72;"	d
ISR	src/FreeRTOS_AVR/utility/port.c	/^ISR(TIMER0_COMPA_vect)$/;"	f
ISR	src/FreeRTOS_AVR/utility/port.c	/^ISR(TIMER0_COMPA_vect, ISR_NAKED)$/;"	f
LIST_H	src/FreeRTOS_AVR/utility/list.h	103;"	d
ListItem_t	src/FreeRTOS_AVR/utility/list.h	/^typedef struct xLIST_ITEM ListItem_t;					\/* For some reason lint wants this as two separate definitions. *\/$/;"	t	typeref:struct:xLIST_ITEM
List_t	src/FreeRTOS_AVR/utility/list.h	/^} List_t;$/;"	t	typeref:struct:xLIST
MPU_WRAPPERS_H	src/FreeRTOS_AVR/utility/mpu_wrappers.h	71;"	d
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	src/FreeRTOS_AVR/utility/event_groups.c	76;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	src/FreeRTOS_AVR/utility/event_groups.c	88;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	src/FreeRTOS_AVR/utility/heap_3.c	87;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	src/FreeRTOS_AVR/utility/heap_3.c	92;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	src/FreeRTOS_AVR/utility/queue.c	76;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	src/FreeRTOS_AVR/utility/queue.c	90;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	src/FreeRTOS_AVR/utility/tasks.c	77;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	src/FreeRTOS_AVR/utility/tasks.c	89;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	src/FreeRTOS_AVR/utility/timers.c	76;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	src/FreeRTOS_AVR/utility/timers.c	91;"	d	file:
MemoryRegion_t	src/FreeRTOS_AVR/utility/task.h	/^} MemoryRegion_t;$/;"	t	typeref:struct:xMEMORY_REGION
MiniListItem_t	src/FreeRTOS_AVR/utility/list.h	/^typedef struct xMINI_LIST_ITEM MiniListItem_t;$/;"	t	typeref:struct:xMINI_LIST_ITEM
PORTABLE_H	src/FreeRTOS_AVR/utility/portable.h	75;"	d
PORTMACRO_H	src/FreeRTOS_AVR/utility/portmacro.h	78;"	d
PRIVILEGED_DATA	src/FreeRTOS_AVR/utility/mpu_wrappers.h	163;"	d
PRIVILEGED_DATA	src/FreeRTOS_AVR/utility/mpu_wrappers.h	170;"	d
PRIVILEGED_FUNCTION	src/FreeRTOS_AVR/utility/mpu_wrappers.h	157;"	d
PRIVILEGED_FUNCTION	src/FreeRTOS_AVR/utility/mpu_wrappers.h	162;"	d
PRIVILEGED_FUNCTION	src/FreeRTOS_AVR/utility/mpu_wrappers.h	169;"	d
PROJDEFS_H	src/FreeRTOS_AVR/utility/projdefs.h	71;"	d
PendedFunction_t	src/FreeRTOS_AVR/utility/timers.h	/^typedef void (*PendedFunction_t)( void *, uint32_t );$/;"	t
QUEUE_H	src/FreeRTOS_AVR/utility/queue.h	72;"	d
QUEUE_REGISTRY_ITEM	src/FreeRTOS_AVR/utility/queue.c	/^	typedef struct QUEUE_REGISTRY_ITEM$/;"	s	file:
QueueDefinition	src/FreeRTOS_AVR/utility/queue.c	/^typedef struct QueueDefinition$/;"	s	file:
QueueHandle_t	src/FreeRTOS_AVR/utility/queue.h	/^typedef void * QueueHandle_t;$/;"	t
QueueRegistryItem_t	src/FreeRTOS_AVR/utility/queue.c	/^	typedef xQueueRegistryItem QueueRegistryItem_t;$/;"	t	file:
QueueSetHandle_t	src/FreeRTOS_AVR/utility/queue.h	/^typedef void * QueueSetHandle_t;$/;"	t
QueueSetMemberHandle_t	src/FreeRTOS_AVR/utility/queue.h	/^typedef void * QueueSetMemberHandle_t;$/;"	t
Queue_t	src/FreeRTOS_AVR/utility/queue.c	/^typedef xQUEUE Queue_t;$/;"	t	file:
SEMAPHORE_H	src/FreeRTOS_AVR/utility/semphr.h	71;"	d
SIG_OUTPUT_COMPARE1A	src/FreeRTOS_AVR/utility/port.c	/^	void SIG_OUTPUT_COMPARE1A( void )$/;"	f
STACK_MACROS_H	src/FreeRTOS_AVR/utility/StackMacros.h	71;"	d
SemaphoreHandle_t	src/FreeRTOS_AVR/utility/semphr.h	/^typedef QueueHandle_t SemaphoreHandle_t;$/;"	t
StackType_t	src/FreeRTOS_AVR/utility/portmacro.h	/^typedef portSTACK_TYPE StackType_t;$/;"	t
TCB_t	src/FreeRTOS_AVR/utility/port.c	/^typedef void TCB_t;$/;"	t	file:
TCB_t	src/FreeRTOS_AVR/utility/tasks.c	/^typedef tskTCB TCB_t;$/;"	t	file:
TIMERS_H	src/FreeRTOS_AVR/utility/timers.h	72;"	d
TaskFunction_t	src/FreeRTOS_AVR/utility/projdefs.h	/^typedef void (*TaskFunction_t)( void * );$/;"	t
TaskHandle_t	src/FreeRTOS_AVR/utility/task.h	/^typedef void * TaskHandle_t;$/;"	t
TaskHandle_t	src/kmu_framework.h	/^typedef void * TaskHandle_t;$/;"	t
TaskHookFunction_t	src/FreeRTOS_AVR/utility/task.h	/^typedef BaseType_t (*TaskHookFunction_t)( void * );$/;"	t
TaskParameters_t	src/FreeRTOS_AVR/utility/task.h	/^} TaskParameters_t;$/;"	t	typeref:struct:xTASK_PARAMETERS
TaskStatus_t	src/FreeRTOS_AVR/utility/task.h	/^} TaskStatus_t;$/;"	t	typeref:struct:xTASK_STATUS
TickType_t	src/FreeRTOS_AVR/utility/portmacro.h	/^	typedef uint16_t TickType_t;$/;"	t
TickType_t	src/FreeRTOS_AVR/utility/portmacro.h	/^	typedef uint32_t TickType_t;$/;"	t
TimeOut_t	src/FreeRTOS_AVR/utility/task.h	/^} TimeOut_t;$/;"	t	typeref:struct:xTIME_OUT
TimerCallbackFunction_t	src/FreeRTOS_AVR/utility/timers.h	/^typedef void (*TimerCallbackFunction_t)( TimerHandle_t xTimer );$/;"	t
TimerHandle_t	src/FreeRTOS_AVR/utility/timers.h	/^typedef void * TimerHandle_t;$/;"	t
TimerParameter_t	src/FreeRTOS_AVR/utility/timers.c	/^} TimerParameter_t;$/;"	t	typeref:struct:tmrTimerParameters	file:
Timer_t	src/FreeRTOS_AVR/utility/timers.c	/^typedef xTIMER Timer_t;$/;"	t	file:
UBaseType_t	src/FreeRTOS_AVR/utility/portmacro.h	/^typedef unsigned char UBaseType_t;$/;"	t
assertBlink	src/FreeRTOS_AVR/FreeRTOS_AVR.c	/^void assertBlink() {$/;"	f
assertMsg	src/FreeRTOS_AVR/assertMsg.cpp	/^void assertMsg(const char* file, int line) {$/;"	f
configAPPLICATION_ALLOCATED_HEAP	src/FreeRTOS_AVR/utility/FreeRTOS.h	763;"	d
configASSERT	src/FreeRTOS_AVR/utility/FreeRTOS.h	259;"	d
configASSERT	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	139;"	d
configASSERT_DEFINED	src/FreeRTOS_AVR/utility/FreeRTOS.h	260;"	d
configASSERT_DEFINED	src/FreeRTOS_AVR/utility/FreeRTOS.h	262;"	d
configCHECK_FOR_STACK_OVERFLOW	src/FreeRTOS_AVR/utility/FreeRTOS.h	399;"	d
configCHECK_FOR_STACK_OVERFLOW	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	128;"	d
configCPU_CLOCK_HZ	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	91;"	d
configCPU_CLOCK_HZ	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	95;"	d
configENABLE_BACKWARD_COMPATIBILITY	src/FreeRTOS_AVR/utility/FreeRTOS.h	794;"	d
configENABLE_BACKWARD_COMPATIBILITY	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	129;"	d
configEXPECTED_IDLE_TIME_BEFORE_SLEEP	src/FreeRTOS_AVR/utility/FreeRTOS.h	695;"	d
configGENERATE_RUN_TIME_STATS	src/FreeRTOS_AVR/utility/FreeRTOS.h	649;"	d
configIDLE_SHOULD_YIELD	src/FreeRTOS_AVR/utility/FreeRTOS.h	239;"	d
configIDLE_SHOULD_YIELD	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	104;"	d
configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS	src/FreeRTOS_AVR/utility/FreeRTOS.h	727;"	d
configLIST_VOLATILE	src/FreeRTOS_AVR/utility/list.h	134;"	d
configMAX_CO_ROUTINE_PRIORITIES	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	110;"	d
configMAX_NUMBER_OF_TASKS	src/kmu_framework.c	17;"	d	file:
configMAX_PRIORITIES	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	98;"	d
configMAX_TASK_NAME_LEN	src/FreeRTOS_AVR/utility/FreeRTOS.h	235;"	d
configMAX_TASK_NAME_LEN	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	101;"	d
configMINIMAL_STACK_SIZE	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	99;"	d
configNUM_THREAD_LOCAL_STORAGE_POINTERS	src/FreeRTOS_AVR/utility/FreeRTOS.h	199;"	d
configPOST_SLEEP_PROCESSING	src/FreeRTOS_AVR/utility/FreeRTOS.h	711;"	d
configPRE_SLEEP_PROCESSING	src/FreeRTOS_AVR/utility/FreeRTOS.h	707;"	d
configQUEUE_REGISTRY_SIZE	src/FreeRTOS_AVR/utility/FreeRTOS.h	312;"	d
configQUEUE_REGISTRY_SIZE	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	105;"	d
configTICK_RATE_HZ	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	92;"	d
configTICK_RATE_HZ	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	96;"	d
configTOTAL_HEAP_SIZE	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	100;"	d
configUSE_16_BIT_TICKS	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	103;"	d
configUSE_ALTERNATIVE_API	src/FreeRTOS_AVR/utility/FreeRTOS.h	227;"	d
configUSE_APPLICATION_TASK_TAG	src/FreeRTOS_AVR/utility/FreeRTOS.h	195;"	d
configUSE_COUNTING_SEMAPHORES	src/FreeRTOS_AVR/utility/FreeRTOS.h	223;"	d
configUSE_COUNTING_SEMAPHORES	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	107;"	d
configUSE_CO_ROUTINES	src/FreeRTOS_AVR/utility/FreeRTOS.h	165;"	d
configUSE_CO_ROUTINES	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	109;"	d
configUSE_IDLE_HOOK	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	88;"	d
configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES	src/FreeRTOS_AVR/utility/projdefs.h	97;"	d
configUSE_MALLOC_FAILED_HOOK	src/FreeRTOS_AVR/utility/FreeRTOS.h	671;"	d
configUSE_MALLOC_FAILED_HOOK	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	127;"	d
configUSE_MUTEXES	src/FreeRTOS_AVR/utility/FreeRTOS.h	215;"	d
configUSE_MUTEXES	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	124;"	d
configUSE_NEWLIB_REENTRANT	src/FreeRTOS_AVR/utility/FreeRTOS.h	731;"	d
configUSE_PORT_OPTIMISED_TASK_SELECTION	src/FreeRTOS_AVR/utility/FreeRTOS.h	759;"	d
configUSE_PREEMPTION	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	87;"	d
configUSE_QUEUE_SETS	src/FreeRTOS_AVR/utility/FreeRTOS.h	715;"	d
configUSE_RECURSIVE_MUTEXES	src/FreeRTOS_AVR/utility/FreeRTOS.h	211;"	d
configUSE_STATS_FORMATTING_FUNCTIONS	src/FreeRTOS_AVR/utility/FreeRTOS.h	735;"	d
configUSE_TASK_FPU_SUPPORT	src/FreeRTOS_AVR/utility/FreeRTOS.h	827;"	d
configUSE_TASK_NOTIFICATIONS	src/FreeRTOS_AVR/utility/FreeRTOS.h	767;"	d
configUSE_TICKLESS_IDLE	src/FreeRTOS_AVR/utility/FreeRTOS.h	703;"	d
configUSE_TICK_HOOK	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	90;"	d
configUSE_TICK_HOOK	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	94;"	d
configUSE_TIMERS	src/FreeRTOS_AVR/utility/FreeRTOS.h	219;"	d
configUSE_TIME_SLICING	src/FreeRTOS_AVR/utility/FreeRTOS.h	723;"	d
configUSE_TRACE_FACILITY	src/FreeRTOS_AVR/utility/FreeRTOS.h	743;"	d
configUSE_TRACE_FACILITY	src/FreeRTOS_AVR/utility/FreeRTOSConfig.h	102;"	d
corCoRoutineControlBlock	src/FreeRTOS_AVR/utility/croutine.h	/^typedef struct corCoRoutineControlBlock$/;"	s
corINITIAL_STATE	src/FreeRTOS_AVR/utility/croutine.c	100;"	d	file:
crCOROUTINE_CODE	src/FreeRTOS_AVR/utility/croutine.h	/^typedef void (*crCOROUTINE_CODE)( CoRoutineHandle_t, UBaseType_t );$/;"	t
crDELAY	src/FreeRTOS_AVR/utility/croutine.h	332;"	d
crEND	src/FreeRTOS_AVR/utility/croutine.h	277;"	d
crQUEUE_RECEIVE	src/FreeRTOS_AVR/utility/croutine.h	514;"	d
crQUEUE_RECEIVE_FROM_ISR	src/FreeRTOS_AVR/utility/croutine.h	736;"	d
crQUEUE_SEND	src/FreeRTOS_AVR/utility/croutine.h	422;"	d
crQUEUE_SEND_FROM_ISR	src/FreeRTOS_AVR/utility/croutine.h	623;"	d
crSET_STATE0	src/FreeRTOS_AVR/utility/croutine.h	283;"	d
crSET_STATE1	src/FreeRTOS_AVR/utility/croutine.h	284;"	d
crSTART	src/FreeRTOS_AVR/utility/croutine.h	246;"	d
delayMS	src/FreeRTOS_AVR/FreeRTOS_AVR.c	/^static void delayMS(uint32_t millis) {$/;"	f	file:
eAbortSleep	src/FreeRTOS_AVR/utility/task.h	/^	eAbortSleep = 0,		\/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. *\/$/;"	e	enum:__anon4
eBlocked	src/FreeRTOS_AVR/utility/task.h	/^	eBlocked,		\/* The task being queried is in the Blocked state. *\/$/;"	e	enum:__anon2
eCurrentState	src/FreeRTOS_AVR/utility/task.h	/^	eTaskState eCurrentState;		\/* The state in which the task existed when the structure was populated. *\/$/;"	m	struct:xTASK_STATUS
eDeleted	src/FreeRTOS_AVR/utility/task.h	/^	eDeleted		\/* The task being queried has been deleted, but its TCB has not yet been freed. *\/$/;"	e	enum:__anon2
eIncrement	src/FreeRTOS_AVR/utility/task.h	/^	eIncrement,					\/* Increment the task's notification value. *\/$/;"	e	enum:__anon3
eNoAction	src/FreeRTOS_AVR/utility/task.h	/^	eNoAction = 0,				\/* Notify the task without updating its notify value. *\/$/;"	e	enum:__anon3
eNoTasksWaitingTimeout	src/FreeRTOS_AVR/utility/task.h	/^	eNoTasksWaitingTimeout	\/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. *\/$/;"	e	enum:__anon4
eNotWaitingNotification	src/FreeRTOS_AVR/utility/tasks.c	/^	eNotWaitingNotification = 0,$/;"	e	enum:__anon6	file:
eNotified	src/FreeRTOS_AVR/utility/tasks.c	/^	eNotified$/;"	e	enum:__anon6	file:
eNotifyAction	src/FreeRTOS_AVR/utility/task.h	/^} eNotifyAction;$/;"	t	typeref:enum:__anon3
eNotifyState	src/FreeRTOS_AVR/utility/tasks.c	/^		volatile eNotifyValue eNotifyState;$/;"	m	struct:tskTaskControlBlock	file:
eNotifyValue	src/FreeRTOS_AVR/utility/tasks.c	/^} eNotifyValue;$/;"	t	typeref:enum:__anon6	file:
eReady	src/FreeRTOS_AVR/utility/task.h	/^	eReady,			\/* The task being queried is in a read or pending ready list. *\/$/;"	e	enum:__anon2
eRunning	src/FreeRTOS_AVR/utility/task.h	/^	eRunning = 0,	\/* A task is querying the state of itself, so must be running. *\/$/;"	e	enum:__anon2
eSetBits	src/FreeRTOS_AVR/utility/task.h	/^	eSetBits,					\/* Set bits in the task's notification value. *\/$/;"	e	enum:__anon3
eSetValueWithOverwrite	src/FreeRTOS_AVR/utility/task.h	/^	eSetValueWithOverwrite,		\/* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. *\/$/;"	e	enum:__anon3
eSetValueWithoutOverwrite	src/FreeRTOS_AVR/utility/task.h	/^	eSetValueWithoutOverwrite	\/* Set the task's notification value if the previous value has been read by the task. *\/$/;"	e	enum:__anon3
eSleepModeStatus	src/FreeRTOS_AVR/utility/task.h	/^} eSleepModeStatus;$/;"	t	typeref:enum:__anon4
eStandardSleep	src/FreeRTOS_AVR/utility/task.h	/^	eStandardSleep,			\/* Enter a sleep mode that will not last any longer than the expected idle time. *\/$/;"	e	enum:__anon4
eSuspended	src/FreeRTOS_AVR/utility/task.h	/^	eSuspended,		\/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. *\/$/;"	e	enum:__anon2
eTaskConfirmSleepModeStatus	src/FreeRTOS_AVR/utility/tasks.c	/^	eSleepModeStatus eTaskConfirmSleepModeStatus( void )$/;"	f
eTaskGetState	src/FreeRTOS_AVR/utility/mpu_wrappers.h	89;"	d
eTaskGetState	src/FreeRTOS_AVR/utility/tasks.c	/^	eTaskState eTaskGetState( TaskHandle_t xTask )$/;"	f
eTaskState	src/FreeRTOS_AVR/utility/task.h	/^} eTaskState;$/;"	t	typeref:enum:__anon2
eTaskStateGet	src/FreeRTOS_AVR/utility/FreeRTOS.h	798;"	d
eWaitingNotification	src/FreeRTOS_AVR/utility/tasks.c	/^	eWaitingNotification,$/;"	e	enum:__anon6	file:
errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	src/FreeRTOS_AVR/utility/projdefs.h	91;"	d
errQUEUE_BLOCKED	src/FreeRTOS_AVR/utility/projdefs.h	92;"	d
errQUEUE_EMPTY	src/FreeRTOS_AVR/utility/projdefs.h	87;"	d
errQUEUE_FULL	src/FreeRTOS_AVR/utility/projdefs.h	88;"	d
errQUEUE_YIELD	src/FreeRTOS_AVR/utility/projdefs.h	93;"	d
errorBlink	src/FreeRTOS_AVR/FreeRTOS_AVR.c	/^static void errorBlink(int n) {$/;"	f	file:
eventCLEAR_EVENTS_ON_EXIT_BIT	src/FreeRTOS_AVR/utility/event_groups.c	102;"	d	file:
eventCLEAR_EVENTS_ON_EXIT_BIT	src/FreeRTOS_AVR/utility/event_groups.c	107;"	d	file:
eventEVENT_BITS_CONTROL_BYTES	src/FreeRTOS_AVR/utility/event_groups.c	105;"	d	file:
eventEVENT_BITS_CONTROL_BYTES	src/FreeRTOS_AVR/utility/event_groups.c	110;"	d	file:
eventUNBLOCKED_DUE_TO_BIT_SET	src/FreeRTOS_AVR/utility/event_groups.c	103;"	d	file:
eventUNBLOCKED_DUE_TO_BIT_SET	src/FreeRTOS_AVR/utility/event_groups.c	108;"	d	file:
eventWAIT_FOR_ALL_BITS	src/FreeRTOS_AVR/utility/event_groups.c	104;"	d	file:
eventWAIT_FOR_ALL_BITS	src/FreeRTOS_AVR/utility/event_groups.c	109;"	d	file:
fDelay	src/kmu_framework.c	/^void fDelay( long timeDelay )$/;"	f
fHideFunc	src/kmu_framework.c	/^static void fHideFunc(void* fHide){$/;"	f	file:
fHideTasks	src/kmu_framework.c	/^PRIVILEGED_DATA static FHideParams fHideTasks[configMAX_NUMBER_OF_TASKS];$/;"	v	file:
fInitTasks	src/kmu_framework.c	/^static void fInitTasks(void *arg){$/;"	f	file:
fNumberOfTasks	src/kmu_framework.c	/^PRIVILEGED_DATA static UBaseType_t fNumberOfTasks = ( UBaseType_t ) 0U;$/;"	v	file:
fReadyTasks	src/kmu_framework.c	/^PRIVILEGED_DATA static FReadyTask fReadyTasks[configMAX_NUMBER_OF_TASKS];$/;"	v	file:
fSort	src/kmu_framework.c	/^void fSort()$/;"	f
fStart	src/kmu_framework.c	/^void fStart()$/;"	f
fTaskDef	src/kmu_framework.c	/^BaseType_t fTaskDef(void (*funcPtr)(), long fPeriod){$/;"	f
freeHeap	src/FreeRTOS_AVR/FreeRTOS_AVR.c	/^size_t freeHeap() {$/;"	f
funcPtr	src/kmu_framework.h	/^    void (*funcPtr)();$/;"	m	struct:FxHideParams
handler	src/kmu_framework.h	/^    TaskHandle_t handler;$/;"	m	struct:FxReadyTask
listCURRENT_LIST_LENGTH	src/FreeRTOS_AVR/utility/list.h	296;"	d
listFIRST_LIST_INTEGRITY_CHECK_VALUE	src/FreeRTOS_AVR/utility/list.h	150;"	d
listFIRST_LIST_INTEGRITY_CHECK_VALUE	src/FreeRTOS_AVR/utility/list.h	162;"	d
listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE	src/FreeRTOS_AVR/utility/list.h	148;"	d
listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE	src/FreeRTOS_AVR/utility/list.h	160;"	d
listGET_END_MARKER	src/FreeRTOS_AVR/utility/list.h	282;"	d
listGET_HEAD_ENTRY	src/FreeRTOS_AVR/utility/list.h	266;"	d
listGET_ITEM_VALUE_OF_HEAD_ENTRY	src/FreeRTOS_AVR/utility/list.h	258;"	d
listGET_LIST_ITEM_OWNER	src/FreeRTOS_AVR/utility/list.h	230;"	d
listGET_LIST_ITEM_VALUE	src/FreeRTOS_AVR/utility/list.h	249;"	d
listGET_NEXT	src/FreeRTOS_AVR/utility/list.h	274;"	d
listGET_OWNER_OF_HEAD_ENTRY	src/FreeRTOS_AVR/utility/list.h	348;"	d
listGET_OWNER_OF_NEXT_ENTRY	src/FreeRTOS_AVR/utility/list.h	318;"	d
listIS_CONTAINED_WITHIN	src/FreeRTOS_AVR/utility/list.h	359;"	d
listLIST_IS_EMPTY	src/FreeRTOS_AVR/utility/list.h	291;"	d
listLIST_IS_INITIALISED	src/FreeRTOS_AVR/utility/list.h	374;"	d
listLIST_ITEM_CONTAINER	src/FreeRTOS_AVR/utility/list.h	367;"	d
listSECOND_LIST_INTEGRITY_CHECK_VALUE	src/FreeRTOS_AVR/utility/list.h	151;"	d
listSECOND_LIST_INTEGRITY_CHECK_VALUE	src/FreeRTOS_AVR/utility/list.h	163;"	d
listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE	src/FreeRTOS_AVR/utility/list.h	149;"	d
listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE	src/FreeRTOS_AVR/utility/list.h	161;"	d
listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE	src/FreeRTOS_AVR/utility/list.h	152;"	d
listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE	src/FreeRTOS_AVR/utility/list.h	166;"	d
listSET_LIST_INTEGRITY_CHECK_1_VALUE	src/FreeRTOS_AVR/utility/list.h	154;"	d
listSET_LIST_INTEGRITY_CHECK_1_VALUE	src/FreeRTOS_AVR/utility/list.h	168;"	d
listSET_LIST_INTEGRITY_CHECK_2_VALUE	src/FreeRTOS_AVR/utility/list.h	155;"	d
listSET_LIST_INTEGRITY_CHECK_2_VALUE	src/FreeRTOS_AVR/utility/list.h	169;"	d
listSET_LIST_ITEM_OWNER	src/FreeRTOS_AVR/utility/list.h	221;"	d
listSET_LIST_ITEM_VALUE	src/FreeRTOS_AVR/utility/list.h	239;"	d
listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE	src/FreeRTOS_AVR/utility/list.h	153;"	d
listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE	src/FreeRTOS_AVR/utility/list.h	167;"	d
listTEST_LIST_INTEGRITY	src/FreeRTOS_AVR/utility/list.h	157;"	d
listTEST_LIST_INTEGRITY	src/FreeRTOS_AVR/utility/list.h	174;"	d
listTEST_LIST_ITEM_INTEGRITY	src/FreeRTOS_AVR/utility/list.h	156;"	d
listTEST_LIST_ITEM_INTEGRITY	src/FreeRTOS_AVR/utility/list.h	173;"	d
mtCOVERAGE_TEST_DELAY	src/FreeRTOS_AVR/utility/FreeRTOS.h	751;"	d
mtCOVERAGE_TEST_MARKER	src/FreeRTOS_AVR/utility/FreeRTOS.h	747;"	d
pcHead	src/FreeRTOS_AVR/utility/queue.c	/^	int8_t *pcHead;					\/*< Points to the beginning of the queue storage area. *\/$/;"	m	struct:QueueDefinition	file:
pcName	src/FreeRTOS_AVR/utility/task.h	/^	const char * const pcName;	\/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:xTASK_PARAMETERS
pcQueueName	src/FreeRTOS_AVR/utility/queue.c	/^		const char *pcQueueName; \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:QUEUE_REGISTRY_ITEM	file:
pcReadFrom	src/FreeRTOS_AVR/utility/queue.c	/^		int8_t *pcReadFrom;			\/*< Points to the last place that a queued item was read from when the structure is used as a queue. *\/$/;"	m	union:QueueDefinition::__anon5	file:
pcTail	src/FreeRTOS_AVR/utility/queue.c	/^	int8_t *pcTail;					\/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. *\/$/;"	m	struct:QueueDefinition	file:
pcTaskGetTaskName	src/FreeRTOS_AVR/utility/tasks.c	/^	char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f
pcTaskName	src/FreeRTOS_AVR/utility/task.h	/^	const char *pcTaskName;			\/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! *\/ \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:xTASK_STATUS
pcTaskName	src/FreeRTOS_AVR/utility/tasks.c	/^	char				pcTaskName[ configMAX_TASK_NAME_LEN ];\/*< Descriptive name given to the task when created.  Facilitates debugging only. *\/ \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:tskTaskControlBlock	file:
pcTimerGetTimerName	src/FreeRTOS_AVR/utility/mpu_wrappers.h	146;"	d
pcTimerGetTimerName	src/FreeRTOS_AVR/utility/timers.c	/^const char * pcTimerGetTimerName( TimerHandle_t xTimer )$/;"	f
pcTimerName	src/FreeRTOS_AVR/utility/timers.c	/^	const char				*pcTimerName;		\/*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. *\/ \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:tmrTimerControl	file:
pcWriteTo	src/FreeRTOS_AVR/utility/queue.c	/^	int8_t *pcWriteTo;				\/*< Points to the free next place in the storage area. *\/$/;"	m	struct:QueueDefinition	file:
pdFAIL	src/FreeRTOS_AVR/utility/projdefs.h	86;"	d
pdFALSE	src/FreeRTOS_AVR/utility/projdefs.h	82;"	d
pdFREERTOS_BIG_ENDIAN	src/FreeRTOS_AVR/utility/projdefs.h	151;"	d
pdFREERTOS_ERRNO_EACCES	src/FreeRTOS_AVR/utility/projdefs.h	116;"	d
pdFREERTOS_ERRNO_EADDRINUSE	src/FreeRTOS_AVR/utility/projdefs.h	137;"	d
pdFREERTOS_ERRNO_EADDRNOTAVAIL	src/FreeRTOS_AVR/utility/projdefs.h	141;"	d
pdFREERTOS_ERRNO_EAGAIN	src/FreeRTOS_AVR/utility/projdefs.h	113;"	d
pdFREERTOS_ERRNO_EALREADY	src/FreeRTOS_AVR/utility/projdefs.h	140;"	d
pdFREERTOS_ERRNO_EBADE	src/FreeRTOS_AVR/utility/projdefs.h	129;"	d
pdFREERTOS_ERRNO_EBADF	src/FreeRTOS_AVR/utility/projdefs.h	112;"	d
pdFREERTOS_ERRNO_EBUSY	src/FreeRTOS_AVR/utility/projdefs.h	118;"	d
pdFREERTOS_ERRNO_ECANCELED	src/FreeRTOS_AVR/utility/projdefs.h	146;"	d
pdFREERTOS_ERRNO_EEXIST	src/FreeRTOS_AVR/utility/projdefs.h	119;"	d
pdFREERTOS_ERRNO_EFAULT	src/FreeRTOS_AVR/utility/projdefs.h	117;"	d
pdFREERTOS_ERRNO_EFTYPE	src/FreeRTOS_AVR/utility/projdefs.h	130;"	d
pdFREERTOS_ERRNO_EILSEQ	src/FreeRTOS_AVR/utility/projdefs.h	145;"	d
pdFREERTOS_ERRNO_EINPROGRESS	src/FreeRTOS_AVR/utility/projdefs.h	139;"	d
pdFREERTOS_ERRNO_EINVAL	src/FreeRTOS_AVR/utility/projdefs.h	124;"	d
pdFREERTOS_ERRNO_EIO	src/FreeRTOS_AVR/utility/projdefs.h	110;"	d
pdFREERTOS_ERRNO_EISCONN	src/FreeRTOS_AVR/utility/projdefs.h	142;"	d
pdFREERTOS_ERRNO_EISDIR	src/FreeRTOS_AVR/utility/projdefs.h	123;"	d
pdFREERTOS_ERRNO_ENAMETOOLONG	src/FreeRTOS_AVR/utility/projdefs.h	133;"	d
pdFREERTOS_ERRNO_ENMFILE	src/FreeRTOS_AVR/utility/projdefs.h	131;"	d
pdFREERTOS_ERRNO_ENOBUFS	src/FreeRTOS_AVR/utility/projdefs.h	135;"	d
pdFREERTOS_ERRNO_ENODEV	src/FreeRTOS_AVR/utility/projdefs.h	121;"	d
pdFREERTOS_ERRNO_ENOENT	src/FreeRTOS_AVR/utility/projdefs.h	109;"	d
pdFREERTOS_ERRNO_ENOMEDIUM	src/FreeRTOS_AVR/utility/projdefs.h	144;"	d
pdFREERTOS_ERRNO_ENOMEM	src/FreeRTOS_AVR/utility/projdefs.h	115;"	d
pdFREERTOS_ERRNO_ENOPROTOOPT	src/FreeRTOS_AVR/utility/projdefs.h	136;"	d
pdFREERTOS_ERRNO_ENOSPC	src/FreeRTOS_AVR/utility/projdefs.h	125;"	d
pdFREERTOS_ERRNO_ENOTCONN	src/FreeRTOS_AVR/utility/projdefs.h	143;"	d
pdFREERTOS_ERRNO_ENOTDIR	src/FreeRTOS_AVR/utility/projdefs.h	122;"	d
pdFREERTOS_ERRNO_ENOTEMPTY	src/FreeRTOS_AVR/utility/projdefs.h	132;"	d
pdFREERTOS_ERRNO_ENXIO	src/FreeRTOS_AVR/utility/projdefs.h	111;"	d
pdFREERTOS_ERRNO_EOPNOTSUPP	src/FreeRTOS_AVR/utility/projdefs.h	134;"	d
pdFREERTOS_ERRNO_EROFS	src/FreeRTOS_AVR/utility/projdefs.h	127;"	d
pdFREERTOS_ERRNO_ESPIPE	src/FreeRTOS_AVR/utility/projdefs.h	126;"	d
pdFREERTOS_ERRNO_ETIMEDOUT	src/FreeRTOS_AVR/utility/projdefs.h	138;"	d
pdFREERTOS_ERRNO_EUNATCH	src/FreeRTOS_AVR/utility/projdefs.h	128;"	d
pdFREERTOS_ERRNO_EWOULDBLOCK	src/FreeRTOS_AVR/utility/projdefs.h	114;"	d
pdFREERTOS_ERRNO_EXDEV	src/FreeRTOS_AVR/utility/projdefs.h	120;"	d
pdFREERTOS_ERRNO_NONE	src/FreeRTOS_AVR/utility/projdefs.h	108;"	d
pdFREERTOS_LITTLE_ENDIAN	src/FreeRTOS_AVR/utility/projdefs.h	150;"	d
pdINTEGRITY_CHECK_VALUE	src/FreeRTOS_AVR/utility/projdefs.h	101;"	d
pdINTEGRITY_CHECK_VALUE	src/FreeRTOS_AVR/utility/projdefs.h	103;"	d
pdMS_TO_TICKS	src/FreeRTOS_AVR/utility/projdefs.h	80;"	d
pdPASS	src/FreeRTOS_AVR/utility/projdefs.h	85;"	d
pdTASK_CODE	src/FreeRTOS_AVR/utility/FreeRTOS.h	817;"	d
pdTASK_HOOK_CODE	src/FreeRTOS_AVR/utility/FreeRTOS.h	811;"	d
pdTRUE	src/FreeRTOS_AVR/utility/projdefs.h	83;"	d
period	src/kmu_framework.h	/^    long period;$/;"	m	struct:FxHideParams
period	src/kmu_framework.h	/^    long period;$/;"	m	struct:FxReadyTask
portASSERT_IF_INTERRUPT_PRIORITY_INVALID	src/FreeRTOS_AVR/utility/FreeRTOS.h	739;"	d
portASSERT_IF_IN_ISR	src/FreeRTOS_AVR/utility/FreeRTOS.h	755;"	d
portBASE_TYPE	src/FreeRTOS_AVR/utility/portmacro.h	101;"	d
portBYTE_ALIGNMENT	src/FreeRTOS_AVR/utility/portmacro.h	131;"	d
portBYTE_ALIGNMENT_MASK	src/FreeRTOS_AVR/utility/portable.h	102;"	d
portBYTE_ALIGNMENT_MASK	src/FreeRTOS_AVR/utility/portable.h	106;"	d
portBYTE_ALIGNMENT_MASK	src/FreeRTOS_AVR/utility/portable.h	110;"	d
portBYTE_ALIGNMENT_MASK	src/FreeRTOS_AVR/utility/portable.h	114;"	d
portBYTE_ALIGNMENT_MASK	src/FreeRTOS_AVR/utility/portable.h	118;"	d
portBYTE_ALIGNMENT_MASK	src/FreeRTOS_AVR/utility/portable.h	98;"	d
portCHAR	src/FreeRTOS_AVR/utility/portmacro.h	95;"	d
portCLEAN_UP_TCB	src/FreeRTOS_AVR/utility/FreeRTOS.h	300;"	d
portCLEAR_COUNTER_ON_MATCH	src/FreeRTOS_AVR/utility/port.c	92;"	d	file:
portCLEAR_INTERRUPT_MASK_FROM_ISR	src/FreeRTOS_AVR/utility/FreeRTOS.h	296;"	d
portCLOCK_PRESCALER	src/FreeRTOS_AVR/utility/port.c	94;"	d	file:
portCOMPARE_MATCH_A_INTERRUPT_ENABLE	src/FreeRTOS_AVR/utility/port.c	95;"	d	file:
portCONFIGURE_TIMER_FOR_RUN_TIME_STATS	src/FreeRTOS_AVR/utility/FreeRTOS.h	667;"	d
portCRITICAL_NESTING_IN_TCB	src/FreeRTOS_AVR/utility/FreeRTOS.h	231;"	d
portDISABLE_INTERRUPTS	src/FreeRTOS_AVR/utility/portmacro.h	124;"	d
portDOUBLE	src/FreeRTOS_AVR/utility/portmacro.h	97;"	d
portENABLE_INTERRUPTS	src/FreeRTOS_AVR/utility/portmacro.h	125;"	d
portENTER_CRITICAL	src/FreeRTOS_AVR/utility/portmacro.h	117;"	d
portEXIT_CRITICAL	src/FreeRTOS_AVR/utility/portmacro.h	121;"	d
portFLAGS_INT_ENABLED	src/FreeRTOS_AVR/utility/port.c	89;"	d	file:
portFLOAT	src/FreeRTOS_AVR/utility/portmacro.h	96;"	d
portLONG	src/FreeRTOS_AVR/utility/portmacro.h	98;"	d
portMAX_DELAY	src/FreeRTOS_AVR/utility/portmacro.h	109;"	d
portMAX_DELAY	src/FreeRTOS_AVR/utility/portmacro.h	112;"	d
portNOP	src/FreeRTOS_AVR/utility/portmacro.h	132;"	d
portNUM_CONFIGURABLE_REGIONS	src/FreeRTOS_AVR/utility/portable.h	126;"	d
portPOINTER_SIZE_TYPE	src/FreeRTOS_AVR/utility/FreeRTOS.h	321;"	d
portPRESCALE_64	src/FreeRTOS_AVR/utility/port.c	93;"	d	file:
portPRE_TASK_DELETE_HOOK	src/FreeRTOS_AVR/utility/FreeRTOS.h	304;"	d
portPRIVILEGE_BIT	src/FreeRTOS_AVR/utility/FreeRTOS.h	675;"	d
portRESET_READY_PRIORITY	src/FreeRTOS_AVR/utility/tasks.c	327;"	d	file:
portRESTORE_CONTEXT	src/FreeRTOS_AVR/utility/port.c	225;"	d	file:
portRESTORE_CONTEXT	src/FreeRTOS_AVR/utility/port.c	272;"	d	file:
portSAVE_CONTEXT	src/FreeRTOS_AVR/utility/port.c	124;"	d	file:
portSAVE_CONTEXT	src/FreeRTOS_AVR/utility/port.c	173;"	d	file:
portSETUP_TCB	src/FreeRTOS_AVR/utility/FreeRTOS.h	308;"	d
portSET_INTERRUPT_MASK_FROM_ISR	src/FreeRTOS_AVR/utility/FreeRTOS.h	292;"	d
portSHORT	src/FreeRTOS_AVR/utility/portmacro.h	99;"	d
portSTACK_GROWTH	src/FreeRTOS_AVR/utility/portmacro.h	129;"	d
portSTACK_TYPE	src/FreeRTOS_AVR/utility/portmacro.h	100;"	d
portSUPPRESS_TICKS_AND_SLEEP	src/FreeRTOS_AVR/utility/FreeRTOS.h	691;"	d
portTASK_FUNCTION	src/FreeRTOS_AVR/utility/portmacro.h	142;"	d
portTASK_FUNCTION	src/FreeRTOS_AVR/utility/tasks.c	/^static portTASK_FUNCTION( prvIdleTask, pvParameters )$/;"	f	file:
portTASK_FUNCTION_PROTO	src/FreeRTOS_AVR/utility/portmacro.h	141;"	d
portTASK_USES_FLOATING_POINT	src/FreeRTOS_AVR/utility/FreeRTOS.h	719;"	d
portTICK_PERIOD_MS	src/FreeRTOS_AVR/utility/portmacro.h	130;"	d
portTICK_RATE_MS	src/FreeRTOS_AVR/utility/FreeRTOS.h	812;"	d
portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR	src/FreeRTOS_AVR/utility/FreeRTOS.h	781;"	d
portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR	src/FreeRTOS_AVR/utility/FreeRTOS.h	788;"	d
portTICK_TYPE_ENTER_CRITICAL	src/FreeRTOS_AVR/utility/FreeRTOS.h	778;"	d
portTICK_TYPE_ENTER_CRITICAL	src/FreeRTOS_AVR/utility/FreeRTOS.h	785;"	d
portTICK_TYPE_EXIT_CRITICAL	src/FreeRTOS_AVR/utility/FreeRTOS.h	779;"	d
portTICK_TYPE_EXIT_CRITICAL	src/FreeRTOS_AVR/utility/FreeRTOS.h	786;"	d
portTICK_TYPE_IS_ATOMIC	src/FreeRTOS_AVR/utility/FreeRTOS.h	771;"	d
portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR	src/FreeRTOS_AVR/utility/FreeRTOS.h	780;"	d
portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR	src/FreeRTOS_AVR/utility/FreeRTOS.h	787;"	d
portTickType	src/FreeRTOS_AVR/utility/FreeRTOS.h	799;"	d
portUSING_MPU_WRAPPERS	src/FreeRTOS_AVR/utility/mpu_wrappers.h	171;"	d
portYIELD	src/FreeRTOS_AVR/utility/portmacro.h	137;"	d
portYIELD_WITHIN_API	src/FreeRTOS_AVR/utility/FreeRTOS.h	679;"	d
prvAddCoRoutineToReadyQueue	src/FreeRTOS_AVR/utility/croutine.c	109;"	d	file:
prvAddCurrentTaskToDelayedList	src/FreeRTOS_AVR/utility/tasks.c	/^static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )$/;"	f	file:
prvAddTaskToReadyList	src/FreeRTOS_AVR/utility/tasks.c	389;"	d	file:
prvAllocateTCBAndStack	src/FreeRTOS_AVR/utility/tasks.c	/^static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )$/;"	f	file:
prvCheckDelayedList	src/FreeRTOS_AVR/utility/croutine.c	/^static void prvCheckDelayedList( void )$/;"	f	file:
prvCheckForValidListAndQueue	src/FreeRTOS_AVR/utility/timers.c	/^static void prvCheckForValidListAndQueue( void )$/;"	f	file:
prvCheckPendingReadyList	src/FreeRTOS_AVR/utility/croutine.c	/^static void prvCheckPendingReadyList( void )$/;"	f	file:
prvCheckTasksWaitingTermination	src/FreeRTOS_AVR/utility/tasks.c	/^static void prvCheckTasksWaitingTermination( void )$/;"	f	file:
prvCopyDataFromQueue	src/FreeRTOS_AVR/utility/queue.c	/^static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )$/;"	f	file:
prvCopyDataToQueue	src/FreeRTOS_AVR/utility/queue.c	/^static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )$/;"	f	file:
prvDeleteTCB	src/FreeRTOS_AVR/utility/tasks.c	/^	static void prvDeleteTCB( TCB_t *pxTCB )$/;"	f	file:
prvGetExpectedIdleTime	src/FreeRTOS_AVR/utility/tasks.c	/^	static TickType_t prvGetExpectedIdleTime( void )$/;"	f	file:
prvGetNextExpireTime	src/FreeRTOS_AVR/utility/timers.c	/^static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )$/;"	f	file:
prvGetTCBFromHandle	src/FreeRTOS_AVR/utility/tasks.c	401;"	d	file:
prvInitialiseCoRoutineLists	src/FreeRTOS_AVR/utility/croutine.c	/^static void prvInitialiseCoRoutineLists( void )$/;"	f	file:
prvInitialiseTCBVariables	src/FreeRTOS_AVR/utility/tasks.c	/^static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f	file:
prvInitialiseTaskLists	src/FreeRTOS_AVR/utility/tasks.c	/^static void prvInitialiseTaskLists( void )$/;"	f	file:
prvInsertTimerInActiveList	src/FreeRTOS_AVR/utility/timers.c	/^static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )$/;"	f	file:
prvIsQueueEmpty	src/FreeRTOS_AVR/utility/queue.c	/^static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )$/;"	f	file:
prvIsQueueFull	src/FreeRTOS_AVR/utility/queue.c	/^static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )$/;"	f	file:
prvListTaskWithinSingleList	src/FreeRTOS_AVR/utility/tasks.c	/^	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )$/;"	f	file:
prvLockQueue	src/FreeRTOS_AVR/utility/queue.c	245;"	d	file:
prvNotifyQueueSetContainer	src/FreeRTOS_AVR/utility/queue.c	/^	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )$/;"	f	file:
prvProcessExpiredTimer	src/FreeRTOS_AVR/utility/timers.c	/^static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )$/;"	f	file:
prvProcessReceivedCommands	src/FreeRTOS_AVR/utility/timers.c	/^static void	prvProcessReceivedCommands( void )$/;"	f	file:
prvProcessTimerOrBlockTask	src/FreeRTOS_AVR/utility/timers.c	/^static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )$/;"	f	file:
prvResetNextTaskUnblockTime	src/FreeRTOS_AVR/utility/tasks.c	/^static void prvResetNextTaskUnblockTime( void )$/;"	f	file:
prvSampleTimeNow	src/FreeRTOS_AVR/utility/timers.c	/^static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )$/;"	f	file:
prvSetupTimerInterrupt	src/FreeRTOS_AVR/utility/port.c	/^static void prvSetupTimerInterrupt( void )$/;"	f	file:
prvSwitchTimerLists	src/FreeRTOS_AVR/utility/timers.c	/^static void prvSwitchTimerLists( void )$/;"	f	file:
prvTaskCheckFreeStackSpace	src/FreeRTOS_AVR/utility/tasks.c	/^	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )$/;"	f	file:
prvTaskIsTaskSuspended	src/FreeRTOS_AVR/utility/tasks.c	/^	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )$/;"	f	file:
prvTestWaitCondition	src/FreeRTOS_AVR/utility/event_groups.c	/^static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )$/;"	f	file:
prvTimerTask	src/FreeRTOS_AVR/utility/timers.c	/^static void prvTimerTask( void *pvParameters )$/;"	f	file:
prvUnlockQueue	src/FreeRTOS_AVR/utility/queue.c	/^static void prvUnlockQueue( Queue_t * const pxQueue )$/;"	f	file:
prvWriteNameToBuffer	src/FreeRTOS_AVR/utility/tasks.c	/^	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )$/;"	f	file:
pucStartAddress	src/FreeRTOS_AVR/utility/portable.h	/^	uint8_t *pucStartAddress;$/;"	m	struct:HeapRegion
puxStackBuffer	src/FreeRTOS_AVR/utility/task.h	/^	StackType_t *puxStackBuffer;$/;"	m	struct:xTASK_PARAMETERS
pvBaseAddress	src/FreeRTOS_AVR/utility/task.h	/^	void *pvBaseAddress;$/;"	m	struct:xMEMORY_REGION
pvContainer	src/FreeRTOS_AVR/utility/list.h	/^	void * configLIST_VOLATILE pvContainer;				\/*< Pointer to the list in which this list item is placed (if any). *\/$/;"	m	struct:xLIST_ITEM
pvOwner	src/FreeRTOS_AVR/utility/list.h	/^	void * pvOwner;										\/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. *\/$/;"	m	struct:xLIST_ITEM
pvParameter1	src/FreeRTOS_AVR/utility/timers.c	/^	void *pvParameter1;						\/* << The value that will be used as the callback functions first parameter. *\/$/;"	m	struct:tmrCallbackParameters	file:
pvParameters	src/FreeRTOS_AVR/utility/task.h	/^	void *pvParameters;$/;"	m	struct:xTASK_PARAMETERS
pvPortMalloc	src/FreeRTOS_AVR/utility/heap_3.c	/^void *pvPortMalloc( size_t xWantedSize )$/;"	f
pvPortMalloc	src/FreeRTOS_AVR/utility/mpu_wrappers.h	129;"	d
pvPortMallocAligned	src/FreeRTOS_AVR/utility/FreeRTOS.h	683;"	d
pvTaskCode	src/FreeRTOS_AVR/utility/task.h	/^	TaskFunction_t pvTaskCode;$/;"	m	struct:xTASK_PARAMETERS
pvTaskGetThreadLocalStoragePointer	src/FreeRTOS_AVR/utility/tasks.c	/^	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )$/;"	f
pvTaskIncrementMutexHeldCount	src/FreeRTOS_AVR/utility/tasks.c	/^	void *pvTaskIncrementMutexHeldCount( void )$/;"	f
pvThreadLocalStoragePointers	src/FreeRTOS_AVR/utility/tasks.c	/^		void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];$/;"	m	struct:tskTaskControlBlock	file:
pvTimerGetTimerID	src/FreeRTOS_AVR/utility/mpu_wrappers.h	141;"	d
pvTimerGetTimerID	src/FreeRTOS_AVR/utility/timers.c	/^void *pvTimerGetTimerID( const TimerHandle_t xTimer )$/;"	f
pvTimerID	src/FreeRTOS_AVR/utility/timers.c	/^	void 					*pvTimerID;			\/*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. *\/$/;"	m	struct:tmrTimerControl	file:
pxCallbackFunction	src/FreeRTOS_AVR/utility/timers.c	/^	PendedFunction_t	pxCallbackFunction;	\/* << The callback function to execute. *\/$/;"	m	struct:tmrCallbackParameters	file:
pxCallbackFunction	src/FreeRTOS_AVR/utility/timers.c	/^	TimerCallbackFunction_t	pxCallbackFunction;	\/*<< The function that will be called when the timer expires. *\/$/;"	m	struct:tmrTimerControl	file:
pxCoRoutineFunction	src/FreeRTOS_AVR/utility/croutine.h	/^	crCOROUTINE_CODE 	pxCoRoutineFunction;$/;"	m	struct:corCoRoutineControlBlock
pxCurrentCoRoutine	src/FreeRTOS_AVR/utility/croutine.c	/^CRCB_t * pxCurrentCoRoutine = NULL;$/;"	v
pxCurrentTCB	src/FreeRTOS_AVR/utility/tasks.c	/^PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;$/;"	v
pxCurrentTimerList	src/FreeRTOS_AVR/utility/timers.c	/^PRIVILEGED_DATA static List_t *pxCurrentTimerList;$/;"	v	file:
pxDelayedCoRoutineList	src/FreeRTOS_AVR/utility/croutine.c	/^static List_t * pxDelayedCoRoutineList;									\/*< Points to the delayed co-routine list currently being used. *\/$/;"	v	file:
pxDelayedTaskList	src/FreeRTOS_AVR/utility/tasks.c	/^PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				\/*< Points to the delayed task list currently being used. *\/$/;"	v	file:
pxEndOfStack	src/FreeRTOS_AVR/utility/tasks.c	/^		StackType_t		*pxEndOfStack;		\/*< Points to the end of the stack on architectures where the stack grows up from low memory. *\/$/;"	m	struct:tskTaskControlBlock	file:
pxISR	src/FreeRTOS_AVR/utility/deprecated_definitions.h	/^	typedef void ( __interrupt __far *pxISR )();$/;"	t
pxISR	src/FreeRTOS_AVR/utility/deprecated_definitions.h	/^    typedef void ( __interrupt __far *pxISR )();$/;"	t
pxIndex	src/FreeRTOS_AVR/utility/list.h	/^	ListItem_t * configLIST_VOLATILE pxIndex;			\/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). *\/$/;"	m	struct:xLIST
pxMutexHolder	src/FreeRTOS_AVR/utility/queue.c	108;"	d	file:
pxNext	src/FreeRTOS_AVR/utility/list.h	/^	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		\/*< Pointer to the next ListItem_t in the list. *\/$/;"	m	struct:xLIST_ITEM	typeref:struct:xLIST_ITEM::configLIST_VOLATILE
pxNext	src/FreeRTOS_AVR/utility/list.h	/^	struct xLIST_ITEM * configLIST_VOLATILE pxNext;$/;"	m	struct:xMINI_LIST_ITEM	typeref:struct:xMINI_LIST_ITEM::configLIST_VOLATILE
pxOverflowDelayedCoRoutineList	src/FreeRTOS_AVR/utility/croutine.c	/^static List_t * pxOverflowDelayedCoRoutineList;							\/*< Points to the delayed co-routine list currently being used to hold co-routines that have overflowed the current tick count. *\/$/;"	v	file:
pxOverflowDelayedTaskList	src/FreeRTOS_AVR/utility/tasks.c	/^PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		\/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. *\/$/;"	v	file:
pxOverflowTimerList	src/FreeRTOS_AVR/utility/timers.c	/^PRIVILEGED_DATA static List_t *pxOverflowTimerList;$/;"	v	file:
pxPortInitialiseStack	src/FreeRTOS_AVR/utility/port.c	/^StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )$/;"	f
pxPrevious	src/FreeRTOS_AVR/utility/list.h	/^	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	\/*< Pointer to the previous ListItem_t in the list. *\/$/;"	m	struct:xLIST_ITEM	typeref:struct:xLIST_ITEM::configLIST_VOLATILE
pxPrevious	src/FreeRTOS_AVR/utility/list.h	/^	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;$/;"	m	struct:xMINI_LIST_ITEM	typeref:struct:xMINI_LIST_ITEM::configLIST_VOLATILE
pxQueueSetContainer	src/FreeRTOS_AVR/utility/queue.c	/^		struct QueueDefinition *pxQueueSetContainer;$/;"	m	struct:QueueDefinition	typeref:struct:QueueDefinition::QueueDefinition	file:
pxReadyCoRoutineLists	src/FreeRTOS_AVR/utility/croutine.c	/^static List_t pxReadyCoRoutineLists[ configMAX_CO_ROUTINE_PRIORITIES ];	\/*< Prioritised ready co-routines. *\/$/;"	v	file:
pxReadyTasksLists	src/FreeRTOS_AVR/utility/tasks.c	/^PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];\/*< Prioritised ready tasks. *\/$/;"	v	file:
pxStack	src/FreeRTOS_AVR/utility/tasks.c	/^	StackType_t			*pxStack;			\/*< Points to the start of the stack. *\/$/;"	m	struct:tskTaskControlBlock	file:
pxTaskTag	src/FreeRTOS_AVR/utility/tasks.c	/^		TaskHookFunction_t pxTaskTag;$/;"	m	struct:tskTaskControlBlock	file:
pxTimer	src/FreeRTOS_AVR/utility/timers.c	/^	Timer_t *			pxTimer;			\/*<< The timer to which the command will be applied. *\/$/;"	m	struct:tmrTimerParameters	file:
pxTopOfStack	src/FreeRTOS_AVR/utility/tasks.c	/^	volatile StackType_t	*pxTopOfStack;	\/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. *\/$/;"	m	struct:tskTaskControlBlock	file:
queueLOCKED_UNMODIFIED	src/FreeRTOS_AVR/utility/queue.c	95;"	d	file:
queueMUTEX_GIVE_BLOCK_TIME	src/FreeRTOS_AVR/utility/queue.c	115;"	d	file:
queueOVERWRITE	src/FreeRTOS_AVR/utility/queue.h	107;"	d
queueQUEUE_IS_MUTEX	src/FreeRTOS_AVR/utility/queue.c	110;"	d	file:
queueQUEUE_TYPE_BASE	src/FreeRTOS_AVR/utility/queue.h	110;"	d
queueQUEUE_TYPE_BINARY_SEMAPHORE	src/FreeRTOS_AVR/utility/queue.h	114;"	d
queueQUEUE_TYPE_COUNTING_SEMAPHORE	src/FreeRTOS_AVR/utility/queue.h	113;"	d
queueQUEUE_TYPE_MUTEX	src/FreeRTOS_AVR/utility/queue.h	112;"	d
queueQUEUE_TYPE_RECURSIVE_MUTEX	src/FreeRTOS_AVR/utility/queue.h	115;"	d
queueQUEUE_TYPE_SET	src/FreeRTOS_AVR/utility/queue.h	111;"	d
queueSEMAPHORE_QUEUE_ITEM_LENGTH	src/FreeRTOS_AVR/utility/queue.c	114;"	d	file:
queueSEND_TO_BACK	src/FreeRTOS_AVR/utility/queue.h	105;"	d
queueSEND_TO_FRONT	src/FreeRTOS_AVR/utility/queue.h	106;"	d
queueUNLOCKED	src/FreeRTOS_AVR/utility/queue.c	94;"	d	file:
queueYIELD_IF_USING_PREEMPTION	src/FreeRTOS_AVR/utility/queue.c	120;"	d	file:
queueYIELD_IF_USING_PREEMPTION	src/FreeRTOS_AVR/utility/queue.c	122;"	d	file:
semBINARY_SEMAPHORE_QUEUE_LENGTH	src/FreeRTOS_AVR/utility/semphr.h	81;"	d
semGIVE_BLOCK_TIME	src/FreeRTOS_AVR/utility/semphr.h	83;"	d
semSEMAPHORE_QUEUE_ITEM_LENGTH	src/FreeRTOS_AVR/utility/semphr.h	82;"	d
static	src/FreeRTOS_AVR/utility/croutine.c	82;"	d	file:
static	src/FreeRTOS_AVR/utility/tasks.c	206;"	d	file:
taskCHECK_FOR_STACK_OVERFLOW	src/FreeRTOS_AVR/utility/StackMacros.h	107;"	d
taskCHECK_FOR_STACK_OVERFLOW	src/FreeRTOS_AVR/utility/StackMacros.h	122;"	d
taskCHECK_FOR_STACK_OVERFLOW	src/FreeRTOS_AVR/utility/StackMacros.h	141;"	d
taskCHECK_FOR_STACK_OVERFLOW	src/FreeRTOS_AVR/utility/StackMacros.h	165;"	d
taskCHECK_FOR_STACK_OVERFLOW	src/FreeRTOS_AVR/utility/StackMacros.h	92;"	d
taskDISABLE_INTERRUPTS	src/FreeRTOS_AVR/utility/task.h	241;"	d
taskENABLE_INTERRUPTS	src/FreeRTOS_AVR/utility/task.h	251;"	d
taskENTER_CRITICAL	src/FreeRTOS_AVR/utility/task.h	216;"	d
taskENTER_CRITICAL_FROM_ISR	src/FreeRTOS_AVR/utility/task.h	217;"	d
taskEVENT_LIST_ITEM_VALUE_IN_USE	src/FreeRTOS_AVR/utility/tasks.c	412;"	d	file:
taskEVENT_LIST_ITEM_VALUE_IN_USE	src/FreeRTOS_AVR/utility/tasks.c	414;"	d	file:
taskEXIT_CRITICAL	src/FreeRTOS_AVR/utility/task.h	231;"	d
taskEXIT_CRITICAL_FROM_ISR	src/FreeRTOS_AVR/utility/task.h	232;"	d
taskRECORD_READY_PRIORITY	src/FreeRTOS_AVR/utility/tasks.c	297;"	d	file:
taskRECORD_READY_PRIORITY	src/FreeRTOS_AVR/utility/tasks.c	336;"	d	file:
taskRESET_READY_PRIORITY	src/FreeRTOS_AVR/utility/tasks.c	326;"	d	file:
taskRESET_READY_PRIORITY	src/FreeRTOS_AVR/utility/tasks.c	355;"	d	file:
taskSCHEDULER_NOT_STARTED	src/FreeRTOS_AVR/utility/task.h	257;"	d
taskSCHEDULER_RUNNING	src/FreeRTOS_AVR/utility/task.h	258;"	d
taskSCHEDULER_SUSPENDED	src/FreeRTOS_AVR/utility/task.h	256;"	d
taskSELECT_HIGHEST_PRIORITY_TASK	src/FreeRTOS_AVR/utility/tasks.c	307;"	d	file:
taskSELECT_HIGHEST_PRIORITY_TASK	src/FreeRTOS_AVR/utility/tasks.c	340;"	d	file:
taskSWITCH_DELAYED_LISTS	src/FreeRTOS_AVR/utility/tasks.c	369;"	d	file:
taskYIELD	src/FreeRTOS_AVR/utility/task.h	202;"	d
taskYIELD_IF_USING_PREEMPTION	src/FreeRTOS_AVR/utility/tasks.c	116;"	d	file:
taskYIELD_IF_USING_PREEMPTION	src/FreeRTOS_AVR/utility/tasks.c	118;"	d	file:
tmrCOMMAND_CHANGE_PERIOD	src/FreeRTOS_AVR/utility/timers.h	102;"	d
tmrCOMMAND_CHANGE_PERIOD_FROM_ISR	src/FreeRTOS_AVR/utility/timers.h	109;"	d
tmrCOMMAND_DELETE	src/FreeRTOS_AVR/utility/timers.h	103;"	d
tmrCOMMAND_EXECUTE_CALLBACK	src/FreeRTOS_AVR/utility/timers.h	97;"	d
tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR	src/FreeRTOS_AVR/utility/timers.h	96;"	d
tmrCOMMAND_RESET	src/FreeRTOS_AVR/utility/timers.h	100;"	d
tmrCOMMAND_RESET_FROM_ISR	src/FreeRTOS_AVR/utility/timers.h	107;"	d
tmrCOMMAND_START	src/FreeRTOS_AVR/utility/timers.h	99;"	d
tmrCOMMAND_START_DONT_TRACE	src/FreeRTOS_AVR/utility/timers.h	98;"	d
tmrCOMMAND_START_FROM_ISR	src/FreeRTOS_AVR/utility/timers.h	106;"	d
tmrCOMMAND_STOP	src/FreeRTOS_AVR/utility/timers.h	101;"	d
tmrCOMMAND_STOP_FROM_ISR	src/FreeRTOS_AVR/utility/timers.h	108;"	d
tmrCallbackParameters	src/FreeRTOS_AVR/utility/timers.c	/^typedef struct tmrCallbackParameters$/;"	s	file:
tmrFIRST_FROM_ISR_COMMAND	src/FreeRTOS_AVR/utility/timers.h	105;"	d
tmrNO_DELAY	src/FreeRTOS_AVR/utility/timers.c	101;"	d	file:
tmrTIMER_CALLBACK	src/FreeRTOS_AVR/utility/FreeRTOS.h	816;"	d
tmrTimerControl	src/FreeRTOS_AVR/utility/timers.c	/^typedef struct tmrTimerControl$/;"	s	file:
tmrTimerParameters	src/FreeRTOS_AVR/utility/timers.c	/^typedef struct tmrTimerParameters$/;"	s	file:
tmrTimerQueueMessage	src/FreeRTOS_AVR/utility/timers.c	/^typedef struct tmrTimerQueueMessage$/;"	s	file:
traceBLOCKING_ON_QUEUE_RECEIVE	src/FreeRTOS_AVR/utility/FreeRTOS.h	387;"	d
traceBLOCKING_ON_QUEUE_SEND	src/FreeRTOS_AVR/utility/FreeRTOS.h	395;"	d
traceCREATE_COUNTING_SEMAPHORE	src/FreeRTOS_AVR/utility/FreeRTOS.h	441;"	d
traceCREATE_COUNTING_SEMAPHORE_FAILED	src/FreeRTOS_AVR/utility/FreeRTOS.h	445;"	d
traceCREATE_MUTEX	src/FreeRTOS_AVR/utility/FreeRTOS.h	417;"	d
traceCREATE_MUTEX_FAILED	src/FreeRTOS_AVR/utility/FreeRTOS.h	421;"	d
traceEND	src/FreeRTOS_AVR/utility/FreeRTOS.h	334;"	d
traceEVENT_GROUP_CLEAR_BITS	src/FreeRTOS_AVR/utility/FreeRTOS.h	589;"	d
traceEVENT_GROUP_CLEAR_BITS_FROM_ISR	src/FreeRTOS_AVR/utility/FreeRTOS.h	593;"	d
traceEVENT_GROUP_CREATE	src/FreeRTOS_AVR/utility/FreeRTOS.h	565;"	d
traceEVENT_GROUP_CREATE_FAILED	src/FreeRTOS_AVR/utility/FreeRTOS.h	569;"	d
traceEVENT_GROUP_DELETE	src/FreeRTOS_AVR/utility/FreeRTOS.h	605;"	d
traceEVENT_GROUP_SET_BITS	src/FreeRTOS_AVR/utility/FreeRTOS.h	597;"	d
traceEVENT_GROUP_SET_BITS_FROM_ISR	src/FreeRTOS_AVR/utility/FreeRTOS.h	601;"	d
traceEVENT_GROUP_SYNC_BLOCK	src/FreeRTOS_AVR/utility/FreeRTOS.h	573;"	d
traceEVENT_GROUP_SYNC_END	src/FreeRTOS_AVR/utility/FreeRTOS.h	577;"	d
traceEVENT_GROUP_WAIT_BITS_BLOCK	src/FreeRTOS_AVR/utility/FreeRTOS.h	581;"	d
traceEVENT_GROUP_WAIT_BITS_END	src/FreeRTOS_AVR/utility/FreeRTOS.h	585;"	d
traceFREE	src/FreeRTOS_AVR/utility/FreeRTOS.h	561;"	d
traceGIVE_MUTEX_RECURSIVE	src/FreeRTOS_AVR/utility/FreeRTOS.h	425;"	d
traceGIVE_MUTEX_RECURSIVE_FAILED	src/FreeRTOS_AVR/utility/FreeRTOS.h	429;"	d
traceINCREASE_TICK_COUNT	src/FreeRTOS_AVR/utility/FreeRTOS.h	346;"	d
traceLOW_POWER_IDLE_BEGIN	src/FreeRTOS_AVR/utility/FreeRTOS.h	351;"	d
traceLOW_POWER_IDLE_END	src/FreeRTOS_AVR/utility/FreeRTOS.h	356;"	d
traceMALLOC	src/FreeRTOS_AVR/utility/FreeRTOS.h	557;"	d
traceMOVED_TASK_TO_READY_STATE	src/FreeRTOS_AVR/utility/FreeRTOS.h	405;"	d
tracePEND_FUNC_CALL	src/FreeRTOS_AVR/utility/FreeRTOS.h	609;"	d
tracePEND_FUNC_CALL_FROM_ISR	src/FreeRTOS_AVR/utility/FreeRTOS.h	613;"	d
traceQUEUE_CREATE	src/FreeRTOS_AVR/utility/FreeRTOS.h	409;"	d
traceQUEUE_CREATE_FAILED	src/FreeRTOS_AVR/utility/FreeRTOS.h	413;"	d
traceQUEUE_DELETE	src/FreeRTOS_AVR/utility/FreeRTOS.h	493;"	d
traceQUEUE_PEEK	src/FreeRTOS_AVR/utility/FreeRTOS.h	461;"	d
traceQUEUE_PEEK_FROM_ISR	src/FreeRTOS_AVR/utility/FreeRTOS.h	465;"	d
traceQUEUE_PEEK_FROM_ISR_FAILED	src/FreeRTOS_AVR/utility/FreeRTOS.h	489;"	d
traceQUEUE_RECEIVE	src/FreeRTOS_AVR/utility/FreeRTOS.h	457;"	d
traceQUEUE_RECEIVE_FAILED	src/FreeRTOS_AVR/utility/FreeRTOS.h	469;"	d
traceQUEUE_RECEIVE_FROM_ISR	src/FreeRTOS_AVR/utility/FreeRTOS.h	481;"	d
traceQUEUE_RECEIVE_FROM_ISR_FAILED	src/FreeRTOS_AVR/utility/FreeRTOS.h	485;"	d
traceQUEUE_REGISTRY_ADD	src/FreeRTOS_AVR/utility/FreeRTOS.h	617;"	d
traceQUEUE_SEND	src/FreeRTOS_AVR/utility/FreeRTOS.h	449;"	d
traceQUEUE_SEND_FAILED	src/FreeRTOS_AVR/utility/FreeRTOS.h	453;"	d
traceQUEUE_SEND_FROM_ISR	src/FreeRTOS_AVR/utility/FreeRTOS.h	473;"	d
traceQUEUE_SEND_FROM_ISR_FAILED	src/FreeRTOS_AVR/utility/FreeRTOS.h	477;"	d
traceSTART	src/FreeRTOS_AVR/utility/FreeRTOS.h	328;"	d
traceTAKE_MUTEX_RECURSIVE	src/FreeRTOS_AVR/utility/FreeRTOS.h	433;"	d
traceTAKE_MUTEX_RECURSIVE_FAILED	src/FreeRTOS_AVR/utility/FreeRTOS.h	437;"	d
traceTASK_CREATE	src/FreeRTOS_AVR/utility/FreeRTOS.h	497;"	d
traceTASK_CREATE_FAILED	src/FreeRTOS_AVR/utility/FreeRTOS.h	501;"	d
traceTASK_DELAY	src/FreeRTOS_AVR/utility/FreeRTOS.h	513;"	d
traceTASK_DELAY_UNTIL	src/FreeRTOS_AVR/utility/FreeRTOS.h	509;"	d
traceTASK_DELETE	src/FreeRTOS_AVR/utility/FreeRTOS.h	505;"	d
traceTASK_INCREMENT_TICK	src/FreeRTOS_AVR/utility/FreeRTOS.h	533;"	d
traceTASK_NOTIFY	src/FreeRTOS_AVR/utility/FreeRTOS.h	637;"	d
traceTASK_NOTIFY_FROM_ISR	src/FreeRTOS_AVR/utility/FreeRTOS.h	641;"	d
traceTASK_NOTIFY_GIVE_FROM_ISR	src/FreeRTOS_AVR/utility/FreeRTOS.h	645;"	d
traceTASK_NOTIFY_TAKE	src/FreeRTOS_AVR/utility/FreeRTOS.h	625;"	d
traceTASK_NOTIFY_TAKE_BLOCK	src/FreeRTOS_AVR/utility/FreeRTOS.h	621;"	d
traceTASK_NOTIFY_WAIT	src/FreeRTOS_AVR/utility/FreeRTOS.h	633;"	d
traceTASK_NOTIFY_WAIT_BLOCK	src/FreeRTOS_AVR/utility/FreeRTOS.h	629;"	d
traceTASK_PRIORITY_DISINHERIT	src/FreeRTOS_AVR/utility/FreeRTOS.h	379;"	d
traceTASK_PRIORITY_INHERIT	src/FreeRTOS_AVR/utility/FreeRTOS.h	371;"	d
traceTASK_PRIORITY_SET	src/FreeRTOS_AVR/utility/FreeRTOS.h	517;"	d
traceTASK_RESUME	src/FreeRTOS_AVR/utility/FreeRTOS.h	525;"	d
traceTASK_RESUME_FROM_ISR	src/FreeRTOS_AVR/utility/FreeRTOS.h	529;"	d
traceTASK_SUSPEND	src/FreeRTOS_AVR/utility/FreeRTOS.h	521;"	d
traceTASK_SWITCHED_IN	src/FreeRTOS_AVR/utility/FreeRTOS.h	340;"	d
traceTASK_SWITCHED_OUT	src/FreeRTOS_AVR/utility/FreeRTOS.h	362;"	d
traceTIMER_COMMAND_RECEIVED	src/FreeRTOS_AVR/utility/FreeRTOS.h	553;"	d
traceTIMER_COMMAND_SEND	src/FreeRTOS_AVR/utility/FreeRTOS.h	545;"	d
traceTIMER_CREATE	src/FreeRTOS_AVR/utility/FreeRTOS.h	537;"	d
traceTIMER_CREATE_FAILED	src/FreeRTOS_AVR/utility/FreeRTOS.h	541;"	d
traceTIMER_EXPIRED	src/FreeRTOS_AVR/utility/FreeRTOS.h	549;"	d
tskBLOCKED_CHAR	src/FreeRTOS_AVR/utility/tasks.c	282;"	d	file:
tskDELETED_CHAR	src/FreeRTOS_AVR/utility/tasks.c	284;"	d	file:
tskIDLE_PRIORITY	src/FreeRTOS_AVR/utility/task.h	192;"	d
tskIDLE_STACK_SIZE	src/FreeRTOS_AVR/utility/tasks.c	111;"	d	file:
tskKERNEL_VERSION_BUILD	src/FreeRTOS_AVR/utility/task.h	91;"	d
tskKERNEL_VERSION_MAJOR	src/FreeRTOS_AVR/utility/task.h	89;"	d
tskKERNEL_VERSION_MINOR	src/FreeRTOS_AVR/utility/task.h	90;"	d
tskKERNEL_VERSION_NUMBER	src/FreeRTOS_AVR/utility/task.h	88;"	d
tskREADY_CHAR	src/FreeRTOS_AVR/utility/tasks.c	283;"	d	file:
tskSTACK_FILL_BYTE	src/FreeRTOS_AVR/utility/tasks.c	277;"	d	file:
tskSUSPENDED_CHAR	src/FreeRTOS_AVR/utility/tasks.c	285;"	d	file:
tskTCB	src/FreeRTOS_AVR/utility/tasks.c	/^} tskTCB;$/;"	t	typeref:struct:tskTaskControlBlock	file:
tskTaskControlBlock	src/FreeRTOS_AVR/utility/tasks.c	/^typedef struct tskTaskControlBlock$/;"	s	file:
u	src/FreeRTOS_AVR/utility/queue.c	/^	} u;$/;"	m	struct:QueueDefinition	typeref:union:QueueDefinition::__anon5	file:
u	src/FreeRTOS_AVR/utility/timers.c	/^	} u;$/;"	m	struct:tmrTimerQueueMessage	typeref:union:tmrTimerQueueMessage::__anon1	file:
ucQueueGetQueueType	src/FreeRTOS_AVR/utility/queue.c	/^	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )$/;"	f
ucQueueType	src/FreeRTOS_AVR/utility/queue.c	/^		uint8_t ucQueueType;$/;"	m	struct:QueueDefinition	file:
ulLengthInBytes	src/FreeRTOS_AVR/utility/task.h	/^	uint32_t ulLengthInBytes;$/;"	m	struct:xMEMORY_REGION
ulNotifiedValue	src/FreeRTOS_AVR/utility/tasks.c	/^		volatile uint32_t ulNotifiedValue;$/;"	m	struct:tskTaskControlBlock	file:
ulParameter2	src/FreeRTOS_AVR/utility/timers.c	/^	uint32_t ulParameter2;					\/* << The value that will be used as the callback functions second parameter. *\/$/;"	m	struct:tmrCallbackParameters	file:
ulParameters	src/FreeRTOS_AVR/utility/task.h	/^	uint32_t ulParameters;$/;"	m	struct:xMEMORY_REGION
ulRunTimeCounter	src/FreeRTOS_AVR/utility/task.h	/^	uint32_t ulRunTimeCounter;		\/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http:\/\/www.freertos.org\/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. *\/$/;"	m	struct:xTASK_STATUS
ulRunTimeCounter	src/FreeRTOS_AVR/utility/tasks.c	/^		uint32_t		ulRunTimeCounter;	\/*< Stores the amount of time the task has spent in the Running state. *\/$/;"	m	struct:tskTaskControlBlock	file:
ulTaskNotifyTake	src/FreeRTOS_AVR/utility/mpu_wrappers.h	108;"	d
ulTaskNotifyTake	src/FreeRTOS_AVR/utility/tasks.c	/^	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )$/;"	f
ulTaskSwitchedInTime	src/FreeRTOS_AVR/utility/tasks.c	/^	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	\/*< Holds the value of a timer\/counter the last time a task was switched in. *\/$/;"	v	file:
ulTotalRunTime	src/FreeRTOS_AVR/utility/tasks.c	/^	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		\/*< Holds the total amount of execution time as defined by the run time counter clock. *\/$/;"	v	file:
usStackDepth	src/FreeRTOS_AVR/utility/task.h	/^	uint16_t usStackDepth;$/;"	m	struct:xTASK_PARAMETERS
usStackHighWaterMark	src/FreeRTOS_AVR/utility/task.h	/^	uint16_t usStackHighWaterMark;	\/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. *\/$/;"	m	struct:xTASK_STATUS
uxAutoReload	src/FreeRTOS_AVR/utility/timers.c	/^	UBaseType_t				uxAutoReload;		\/*<< Set to pdTRUE if the timer should be automatically restarted once expired.  Set to pdFALSE if the timer is, in effect, a one-shot timer. *\/$/;"	m	struct:tmrTimerControl	file:
uxBasePriority	src/FreeRTOS_AVR/utility/task.h	/^	UBaseType_t uxBasePriority;		\/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. *\/$/;"	m	struct:xTASK_STATUS
uxBasePriority	src/FreeRTOS_AVR/utility/tasks.c	/^		UBaseType_t 	uxBasePriority;		\/*< The priority last assigned to the task - used by the priority inheritance mechanism. *\/$/;"	m	struct:tskTaskControlBlock	file:
uxCriticalNesting	src/FreeRTOS_AVR/utility/tasks.c	/^		UBaseType_t 	uxCriticalNesting; 	\/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. *\/$/;"	m	struct:tskTaskControlBlock	file:
uxCurrentNumberOfTasks	src/FreeRTOS_AVR/utility/tasks.c	/^PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;$/;"	v	file:
uxCurrentPriority	src/FreeRTOS_AVR/utility/task.h	/^	UBaseType_t uxCurrentPriority;	\/* The priority at which the task was running (may be inherited) when the structure was populated. *\/$/;"	m	struct:xTASK_STATUS
uxEventBits	src/FreeRTOS_AVR/utility/event_groups.c	/^	EventBits_t uxEventBits;$/;"	m	struct:xEventGroupDefinition	file:
uxEventGroupGetNumber	src/FreeRTOS_AVR/utility/event_groups.c	/^	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )$/;"	f
uxEventGroupNumber	src/FreeRTOS_AVR/utility/event_groups.c	/^		UBaseType_t uxEventGroupNumber;$/;"	m	struct:xEventGroupDefinition	file:
uxIndex	src/FreeRTOS_AVR/utility/croutine.h	/^	UBaseType_t 		uxIndex;			\/*< Used to distinguish between co-routines when multiple co-routines use the same co-routine function. *\/$/;"	m	struct:corCoRoutineControlBlock
uxItemSize	src/FreeRTOS_AVR/utility/queue.c	/^	UBaseType_t uxItemSize;			\/*< The size of each items that the queue will hold. *\/$/;"	m	struct:QueueDefinition	file:
uxLength	src/FreeRTOS_AVR/utility/queue.c	/^	UBaseType_t uxLength;			\/*< The length of the queue defined as the number of items it will hold, not the number of bytes. *\/$/;"	m	struct:QueueDefinition	file:
uxListRemove	src/FreeRTOS_AVR/utility/list.c	/^UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )$/;"	f
uxMessagesWaiting	src/FreeRTOS_AVR/utility/queue.c	/^	volatile UBaseType_t uxMessagesWaiting;\/*< The number of items currently in the queue. *\/$/;"	m	struct:QueueDefinition	file:
uxMutexesHeld	src/FreeRTOS_AVR/utility/tasks.c	/^		UBaseType_t 	uxMutexesHeld;$/;"	m	struct:tskTaskControlBlock	file:
uxNumberOfItems	src/FreeRTOS_AVR/utility/list.h	/^	configLIST_VOLATILE UBaseType_t uxNumberOfItems;$/;"	m	struct:xLIST
uxPendedTicks	src/FreeRTOS_AVR/utility/tasks.c	/^PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;$/;"	v	file:
uxPriority	src/FreeRTOS_AVR/utility/croutine.h	/^	UBaseType_t 		uxPriority;			\/*< The priority of the co-routine in relation to other co-routines. *\/$/;"	m	struct:corCoRoutineControlBlock
uxPriority	src/FreeRTOS_AVR/utility/task.h	/^	UBaseType_t uxPriority;$/;"	m	struct:xTASK_PARAMETERS
uxPriority	src/FreeRTOS_AVR/utility/tasks.c	/^	UBaseType_t			uxPriority;			\/*< The priority of the task.  0 is the lowest priority. *\/$/;"	m	struct:tskTaskControlBlock	file:
uxQueueGetQueueNumber	src/FreeRTOS_AVR/utility/queue.c	/^	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )$/;"	f
uxQueueMessagesWaiting	src/FreeRTOS_AVR/utility/mpu_wrappers.h	119;"	d
uxQueueMessagesWaiting	src/FreeRTOS_AVR/utility/queue.c	/^UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )$/;"	f
uxQueueMessagesWaitingFromISR	src/FreeRTOS_AVR/utility/queue.c	/^UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )$/;"	f
uxQueueNumber	src/FreeRTOS_AVR/utility/queue.c	/^		UBaseType_t uxQueueNumber;$/;"	m	struct:QueueDefinition	file:
uxQueueSpacesAvailable	src/FreeRTOS_AVR/utility/queue.c	/^UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )$/;"	f
uxQueueType	src/FreeRTOS_AVR/utility/queue.c	109;"	d	file:
uxRecursiveCallCount	src/FreeRTOS_AVR/utility/queue.c	/^		UBaseType_t uxRecursiveCallCount;\/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. *\/$/;"	m	union:QueueDefinition::__anon5	file:
uxSchedulerSuspended	src/FreeRTOS_AVR/utility/tasks.c	/^PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;$/;"	v	file:
uxState	src/FreeRTOS_AVR/utility/croutine.h	/^	uint16_t 			uxState;			\/*< Used internally by the co-routine implementation. *\/$/;"	m	struct:corCoRoutineControlBlock
uxTCBNumber	src/FreeRTOS_AVR/utility/tasks.c	/^		UBaseType_t		uxTCBNumber;		\/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. *\/$/;"	m	struct:tskTaskControlBlock	file:
uxTaskGetNumberOfTasks	src/FreeRTOS_AVR/utility/mpu_wrappers.h	95;"	d
uxTaskGetNumberOfTasks	src/FreeRTOS_AVR/utility/tasks.c	/^UBaseType_t uxTaskGetNumberOfTasks( void )$/;"	f
uxTaskGetStackHighWaterMark	src/FreeRTOS_AVR/utility/mpu_wrappers.h	101;"	d
uxTaskGetStackHighWaterMark	src/FreeRTOS_AVR/utility/tasks.c	/^	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )$/;"	f
uxTaskGetSystemState	src/FreeRTOS_AVR/utility/mpu_wrappers.h	105;"	d
uxTaskGetSystemState	src/FreeRTOS_AVR/utility/tasks.c	/^	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )$/;"	f
uxTaskGetTaskNumber	src/FreeRTOS_AVR/utility/tasks.c	/^	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )$/;"	f
uxTaskNumber	src/FreeRTOS_AVR/utility/tasks.c	/^		UBaseType_t  	uxTaskNumber;		\/*< Stores a number specifically for use by third party trace code. *\/$/;"	m	struct:tskTaskControlBlock	file:
uxTaskNumber	src/FreeRTOS_AVR/utility/tasks.c	/^PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;$/;"	v	file:
uxTaskPriorityGet	src/FreeRTOS_AVR/utility/mpu_wrappers.h	87;"	d
uxTaskPriorityGet	src/FreeRTOS_AVR/utility/tasks.c	/^	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )$/;"	f
uxTaskPriorityGetFromISR	src/FreeRTOS_AVR/utility/tasks.c	/^	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )$/;"	f
uxTaskResetEventItemValue	src/FreeRTOS_AVR/utility/tasks.c	/^TickType_t uxTaskResetEventItemValue( void )$/;"	f
uxTasksDeleted	src/FreeRTOS_AVR/utility/tasks.c	/^	PRIVILEGED_DATA static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;$/;"	v	file:
uxTimerNumber	src/FreeRTOS_AVR/utility/timers.c	/^		UBaseType_t			uxTimerNumber;		\/*<< An ID assigned by trace tools such as FreeRTOS+Trace *\/$/;"	m	struct:tmrTimerControl	file:
uxTopCoRoutineReadyPriority	src/FreeRTOS_AVR/utility/croutine.c	/^static UBaseType_t uxTopCoRoutineReadyPriority = 0;$/;"	v	file:
uxTopReadyPriority	src/FreeRTOS_AVR/utility/tasks.c	/^PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;$/;"	v	file:
vApplicationIdleHook	src/FreeRTOS_AVR/idlehook.c	/^void __attribute__((weak)) vApplicationIdleHook() {$/;"	f
vApplicationMallocFailedHook	src/FreeRTOS_AVR/FreeRTOS_AVR.c	/^void vApplicationMallocFailedHook() {$/;"	f
vApplicationStackOverflowHook	src/FreeRTOS_AVR/FreeRTOS_AVR.c	/^void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName) {$/;"	f
vApplicationTickHook	src/FreeRTOS_AVR/idlehook.c	/^void __attribute__((weak)) vApplicationTickHook() {$/;"	f
vCoRoutineAddToDelayedList	src/FreeRTOS_AVR/utility/croutine.c	/^void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )$/;"	f
vCoRoutineSchedule	src/FreeRTOS_AVR/utility/croutine.c	/^void vCoRoutineSchedule( void )$/;"	f
vEventGroupClearBitsCallback	src/FreeRTOS_AVR/utility/event_groups.c	/^void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )$/;"	f
vEventGroupDelete	src/FreeRTOS_AVR/utility/event_groups.c	/^void vEventGroupDelete( EventGroupHandle_t xEventGroup )$/;"	f
vEventGroupDelete	src/FreeRTOS_AVR/utility/mpu_wrappers.h	154;"	d
vEventGroupSetBitsCallback	src/FreeRTOS_AVR/utility/event_groups.c	/^void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )$/;"	f
vListInitialise	src/FreeRTOS_AVR/utility/list.c	/^void vListInitialise( List_t * const pxList )$/;"	f
vListInitialiseItem	src/FreeRTOS_AVR/utility/list.c	/^void vListInitialiseItem( ListItem_t * const pxItem )$/;"	f
vListInsert	src/FreeRTOS_AVR/utility/list.c	/^void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )$/;"	f
vListInsertEnd	src/FreeRTOS_AVR/utility/list.c	/^void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )$/;"	f
vPortEndScheduler	src/FreeRTOS_AVR/utility/port.c	/^void vPortEndScheduler( void )$/;"	f
vPortFree	src/FreeRTOS_AVR/utility/heap_3.c	/^void vPortFree( void *pv )$/;"	f
vPortFree	src/FreeRTOS_AVR/utility/mpu_wrappers.h	130;"	d
vPortFreeAligned	src/FreeRTOS_AVR/utility/FreeRTOS.h	687;"	d
vPortInitialiseBlocks	src/FreeRTOS_AVR/utility/mpu_wrappers.h	132;"	d
vPortYield	src/FreeRTOS_AVR/utility/port.c	/^void vPortYield( void )$/;"	f
vPortYieldFromTick	src/FreeRTOS_AVR/utility/port.c	/^void vPortYieldFromTick( void )$/;"	f
vPrintString	src/FreeRTOS_AVR/basic_io_avr.cpp	/^void vPrintString( const char *pcString )$/;"	f
vPrintStringAndNumber	src/FreeRTOS_AVR/basic_io_avr.cpp	/^void vPrintStringAndNumber( const char *pcString, unsigned portLONG ulValue )$/;"	f
vQueueAddToRegistry	src/FreeRTOS_AVR/utility/FreeRTOS.h	316;"	d
vQueueAddToRegistry	src/FreeRTOS_AVR/utility/mpu_wrappers.h	136;"	d
vQueueAddToRegistry	src/FreeRTOS_AVR/utility/queue.c	/^	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f
vQueueDelete	src/FreeRTOS_AVR/utility/mpu_wrappers.h	120;"	d
vQueueDelete	src/FreeRTOS_AVR/utility/queue.c	/^void vQueueDelete( QueueHandle_t xQueue )$/;"	f
vQueueSetQueueNumber	src/FreeRTOS_AVR/utility/queue.c	/^	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )$/;"	f
vQueueUnregisterQueue	src/FreeRTOS_AVR/utility/FreeRTOS.h	317;"	d
vQueueUnregisterQueue	src/FreeRTOS_AVR/utility/mpu_wrappers.h	137;"	d
vQueueUnregisterQueue	src/FreeRTOS_AVR/utility/queue.c	/^	void vQueueUnregisterQueue( QueueHandle_t xQueue )$/;"	f
vQueueWaitForMessageRestricted	src/FreeRTOS_AVR/utility/queue.c	/^	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )$/;"	f
vSemaphoreCreateBinary	src/FreeRTOS_AVR/utility/semphr.h	131;"	d
vSemaphoreDelete	src/FreeRTOS_AVR/utility/semphr.h	825;"	d
vTaskAllocateMPURegions	src/FreeRTOS_AVR/utility/mpu_wrappers.h	83;"	d
vTaskAllocateMPURegions	src/FreeRTOS_AVR/utility/tasks.c	/^	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )$/;"	f
vTaskDelay	src/FreeRTOS_AVR/utility/mpu_wrappers.h	86;"	d
vTaskDelay	src/FreeRTOS_AVR/utility/tasks.c	/^	void vTaskDelay( const TickType_t xTicksToDelay )$/;"	f
vTaskDelayUntil	src/FreeRTOS_AVR/utility/mpu_wrappers.h	85;"	d
vTaskDelayUntil	src/FreeRTOS_AVR/utility/tasks.c	/^	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )$/;"	f
vTaskDelete	src/FreeRTOS_AVR/utility/mpu_wrappers.h	84;"	d
vTaskDelete	src/FreeRTOS_AVR/utility/tasks.c	/^	void vTaskDelete( TaskHandle_t xTaskToDelete )$/;"	f
vTaskEndScheduler	src/FreeRTOS_AVR/utility/tasks.c	/^void vTaskEndScheduler( void )$/;"	f
vTaskEnterCritical	src/FreeRTOS_AVR/utility/tasks.c	/^	void vTaskEnterCritical( void )$/;"	f
vTaskExitCritical	src/FreeRTOS_AVR/utility/tasks.c	/^	void vTaskExitCritical( void )$/;"	f
vTaskGetRunTimeStats	src/FreeRTOS_AVR/utility/mpu_wrappers.h	97;"	d
vTaskGetRunTimeStats	src/FreeRTOS_AVR/utility/tasks.c	/^	void vTaskGetRunTimeStats( char *pcWriteBuffer )$/;"	f
vTaskList	src/FreeRTOS_AVR/utility/mpu_wrappers.h	96;"	d
vTaskList	src/FreeRTOS_AVR/utility/tasks.c	/^	void vTaskList( char * pcWriteBuffer )$/;"	f
vTaskMissedYield	src/FreeRTOS_AVR/utility/tasks.c	/^void vTaskMissedYield( void )$/;"	f
vTaskNotifyGiveFromISR	src/FreeRTOS_AVR/utility/tasks.c	/^	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )$/;"	f
vTaskPlaceOnEventList	src/FreeRTOS_AVR/utility/tasks.c	/^void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )$/;"	f
vTaskPlaceOnEventListRestricted	src/FreeRTOS_AVR/utility/tasks.c	/^	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )$/;"	f
vTaskPlaceOnUnorderedEventList	src/FreeRTOS_AVR/utility/tasks.c	/^void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )$/;"	f
vTaskPriorityInherit	src/FreeRTOS_AVR/utility/tasks.c	/^	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )$/;"	f
vTaskPrioritySet	src/FreeRTOS_AVR/utility/mpu_wrappers.h	88;"	d
vTaskPrioritySet	src/FreeRTOS_AVR/utility/tasks.c	/^	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )$/;"	f
vTaskResume	src/FreeRTOS_AVR/utility/mpu_wrappers.h	91;"	d
vTaskResume	src/FreeRTOS_AVR/utility/tasks.c	/^	void vTaskResume( TaskHandle_t xTaskToResume )$/;"	f
vTaskSetApplicationTaskTag	src/FreeRTOS_AVR/utility/mpu_wrappers.h	98;"	d
vTaskSetApplicationTaskTag	src/FreeRTOS_AVR/utility/tasks.c	/^	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )$/;"	f
vTaskSetTaskNumber	src/FreeRTOS_AVR/utility/tasks.c	/^	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )$/;"	f
vTaskSetThreadLocalStoragePointer	src/FreeRTOS_AVR/utility/tasks.c	/^	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )$/;"	f
vTaskSetTimeOutState	src/FreeRTOS_AVR/utility/tasks.c	/^void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )$/;"	f
vTaskStartScheduler	src/FreeRTOS_AVR/utility/tasks.c	/^void vTaskStartScheduler( void )$/;"	f
vTaskStepTick	src/FreeRTOS_AVR/utility/tasks.c	/^	void vTaskStepTick( const TickType_t xTicksToJump )$/;"	f
vTaskSuspend	src/FreeRTOS_AVR/utility/mpu_wrappers.h	90;"	d
vTaskSuspend	src/FreeRTOS_AVR/utility/tasks.c	/^	void vTaskSuspend( TaskHandle_t xTaskToSuspend )$/;"	f
vTaskSuspendAll	src/FreeRTOS_AVR/utility/mpu_wrappers.h	92;"	d
vTaskSuspendAll	src/FreeRTOS_AVR/utility/tasks.c	/^void vTaskSuspendAll( void )$/;"	f
vTaskSwitchContext	src/FreeRTOS_AVR/utility/tasks.c	/^void vTaskSwitchContext( void )$/;"	f
vTimerSetTimerID	src/FreeRTOS_AVR/utility/mpu_wrappers.h	142;"	d
vTimerSetTimerID	src/FreeRTOS_AVR/utility/timers.c	/^void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )$/;"	f
xActiveTimerList1	src/FreeRTOS_AVR/utility/timers.c	/^PRIVILEGED_DATA static List_t xActiveTimerList1;$/;"	v	file:
xActiveTimerList2	src/FreeRTOS_AVR/utility/timers.c	/^PRIVILEGED_DATA static List_t xActiveTimerList2;$/;"	v	file:
xCallbackParameters	src/FreeRTOS_AVR/utility/timers.c	/^			CallbackParameters_t xCallbackParameters;$/;"	m	union:tmrTimerQueueMessage::__anon1	file:
xCoRoutineCreate	src/FreeRTOS_AVR/utility/croutine.c	/^BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )$/;"	f
xCoRoutineHandle	src/FreeRTOS_AVR/utility/FreeRTOS.h	810;"	d
xCoRoutineRemoveFromEventList	src/FreeRTOS_AVR/utility/croutine.c	/^BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )$/;"	f
xCoRoutineTickCount	src/FreeRTOS_AVR/utility/croutine.c	/^static TickType_t xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;$/;"	v	file:
xDelayedCoRoutineList1	src/FreeRTOS_AVR/utility/croutine.c	/^static List_t xDelayedCoRoutineList1;									\/*< Delayed co-routines. *\/$/;"	v	file:
xDelayedCoRoutineList2	src/FreeRTOS_AVR/utility/croutine.c	/^static List_t xDelayedCoRoutineList2;									\/*< Delayed co-routines (two lists are used - one for delays that have overflowed the current tick count. *\/$/;"	v	file:
xDelayedTaskList1	src/FreeRTOS_AVR/utility/tasks.c	/^PRIVILEGED_DATA static List_t xDelayedTaskList1;						\/*< Delayed tasks. *\/$/;"	v	file:
xDelayedTaskList2	src/FreeRTOS_AVR/utility/tasks.c	/^PRIVILEGED_DATA static List_t xDelayedTaskList2;						\/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. *\/$/;"	v	file:
xEventGroupClearBits	src/FreeRTOS_AVR/utility/event_groups.c	/^EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )$/;"	f
xEventGroupClearBits	src/FreeRTOS_AVR/utility/mpu_wrappers.h	151;"	d
xEventGroupClearBitsFromISR	src/FreeRTOS_AVR/utility/event_groups.c	/^	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )$/;"	f
xEventGroupClearBitsFromISR	src/FreeRTOS_AVR/utility/event_groups.h	385;"	d
xEventGroupCreate	src/FreeRTOS_AVR/utility/event_groups.c	/^EventGroupHandle_t xEventGroupCreate( void )$/;"	f
xEventGroupCreate	src/FreeRTOS_AVR/utility/mpu_wrappers.h	149;"	d
xEventGroupDefinition	src/FreeRTOS_AVR/utility/event_groups.c	/^typedef struct xEventGroupDefinition$/;"	s	file:
xEventGroupGetBits	src/FreeRTOS_AVR/utility/event_groups.h	683;"	d
xEventGroupGetBitsFromISR	src/FreeRTOS_AVR/utility/event_groups.c	/^EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )$/;"	f
xEventGroupSetBits	src/FreeRTOS_AVR/utility/event_groups.c	/^EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )$/;"	f
xEventGroupSetBits	src/FreeRTOS_AVR/utility/mpu_wrappers.h	152;"	d
xEventGroupSetBitsFromISR	src/FreeRTOS_AVR/utility/event_groups.c	/^	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )$/;"	f
xEventGroupSetBitsFromISR	src/FreeRTOS_AVR/utility/event_groups.h	537;"	d
xEventGroupSync	src/FreeRTOS_AVR/utility/event_groups.c	/^EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )$/;"	f
xEventGroupSync	src/FreeRTOS_AVR/utility/mpu_wrappers.h	153;"	d
xEventGroupWaitBits	src/FreeRTOS_AVR/utility/event_groups.c	/^EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )$/;"	f
xEventGroupWaitBits	src/FreeRTOS_AVR/utility/mpu_wrappers.h	150;"	d
xEventListItem	src/FreeRTOS_AVR/utility/croutine.h	/^	ListItem_t			xEventListItem;		\/*< List item used to place the CRCB in event lists. *\/$/;"	m	struct:corCoRoutineControlBlock
xEventListItem	src/FreeRTOS_AVR/utility/tasks.c	/^	ListItem_t			xEventListItem;		\/*< Used to reference a task from an event list. *\/$/;"	m	struct:tskTaskControlBlock	file:
xGenericListItem	src/FreeRTOS_AVR/utility/croutine.h	/^	ListItem_t			xGenericListItem;	\/*< List item used to place the CRCB in ready and blocked queues. *\/$/;"	m	struct:corCoRoutineControlBlock
xGenericListItem	src/FreeRTOS_AVR/utility/tasks.c	/^	ListItem_t			xGenericListItem;	\/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). *\/$/;"	m	struct:tskTaskControlBlock	file:
xHandle	src/FreeRTOS_AVR/utility/queue.c	/^		QueueHandle_t xHandle;$/;"	m	struct:QUEUE_REGISTRY_ITEM	file:
xHandle	src/FreeRTOS_AVR/utility/task.h	/^	TaskHandle_t xHandle;			\/* The handle of the task to which the rest of the information in the structure relates. *\/$/;"	m	struct:xTASK_STATUS
xIdleTaskHandle	src/FreeRTOS_AVR/utility/tasks.c	/^	PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;			\/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. *\/$/;"	v	file:
xItemValue	src/FreeRTOS_AVR/utility/list.h	/^	configLIST_VOLATILE TickType_t xItemValue;			\/*< The value being listed.  In most cases this is used to sort the list in descending order. *\/$/;"	m	struct:xLIST_ITEM
xItemValue	src/FreeRTOS_AVR/utility/list.h	/^	configLIST_VOLATILE TickType_t xItemValue;$/;"	m	struct:xMINI_LIST_ITEM
xLIST	src/FreeRTOS_AVR/utility/list.h	/^typedef struct xLIST$/;"	s
xLIST_ITEM	src/FreeRTOS_AVR/utility/list.h	/^struct xLIST_ITEM$/;"	s
xLastTickCount	src/FreeRTOS_AVR/utility/croutine.c	/^static TickType_t xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;$/;"	v	file:
xList	src/FreeRTOS_AVR/utility/FreeRTOS.h	819;"	d
xListEnd	src/FreeRTOS_AVR/utility/list.h	/^	MiniListItem_t xListEnd;							\/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. *\/$/;"	m	struct:xLIST
xListItem	src/FreeRTOS_AVR/utility/FreeRTOS.h	818;"	d
xMEMORY_REGION	src/FreeRTOS_AVR/utility/task.h	/^typedef struct xMEMORY_REGION$/;"	s
xMINI_LIST_ITEM	src/FreeRTOS_AVR/utility/list.h	/^struct xMINI_LIST_ITEM$/;"	s
xMPUSettings	src/FreeRTOS_AVR/utility/tasks.c	/^		xMPU_SETTINGS	xMPUSettings;		\/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. *\/$/;"	m	struct:tskTaskControlBlock	file:
xMemoryRegion	src/FreeRTOS_AVR/utility/FreeRTOS.h	806;"	d
xMessageID	src/FreeRTOS_AVR/utility/timers.c	/^	BaseType_t			xMessageID;			\/*<< The command being sent to the timer service task. *\/$/;"	m	struct:tmrTimerQueueMessage	file:
xMessageValue	src/FreeRTOS_AVR/utility/timers.c	/^	TickType_t			xMessageValue;		\/*<< An optional value used by a subset of commands, for example, when changing the period of a timer. *\/$/;"	m	struct:tmrTimerParameters	file:
xNewLib_reent	src/FreeRTOS_AVR/utility/tasks.c	/^		struct 	_reent xNewLib_reent;$/;"	m	struct:tskTaskControlBlock	typeref:struct:tskTaskControlBlock::_reent	file:
xNextTaskUnblockTime	src/FreeRTOS_AVR/utility/tasks.c	/^PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; \/* Initialised to portMAX_DELAY before the scheduler starts. *\/$/;"	v	file:
xNumOfOverflows	src/FreeRTOS_AVR/utility/tasks.c	/^PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;$/;"	v	file:
xOverflowCount	src/FreeRTOS_AVR/utility/task.h	/^	BaseType_t xOverflowCount;$/;"	m	struct:xTIME_OUT
xPassedTicks	src/FreeRTOS_AVR/utility/croutine.c	/^static TickType_t xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;$/;"	v	file:
xPendingReadyCoRoutineList	src/FreeRTOS_AVR/utility/croutine.c	/^static List_t xPendingReadyCoRoutineList;								\/*< Holds co-routines that have been readied by an external event.  They cannot be added directly to the ready lists as the ready lists cannot be accessed by interrupts. *\/$/;"	v	file:
xPendingReadyList	src/FreeRTOS_AVR/utility/tasks.c	/^PRIVILEGED_DATA static List_t xPendingReadyList;						\/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. *\/$/;"	v	file:
xPortGetFreeHeapSize	src/FreeRTOS_AVR/utility/mpu_wrappers.h	131;"	d
xPortGetMinimumEverFreeHeapSize	src/FreeRTOS_AVR/utility/mpu_wrappers.h	133;"	d
xPortStartScheduler	src/FreeRTOS_AVR/utility/port.c	/^BaseType_t xPortStartScheduler( void )$/;"	f
xQUEUE	src/FreeRTOS_AVR/utility/queue.c	/^} xQUEUE;$/;"	t	typeref:struct:QueueDefinition	file:
xQueueAddToSet	src/FreeRTOS_AVR/utility/mpu_wrappers.h	124;"	d
xQueueAddToSet	src/FreeRTOS_AVR/utility/queue.c	/^	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )$/;"	f
xQueueAltGenericReceive	src/FreeRTOS_AVR/utility/mpu_wrappers.h	117;"	d
xQueueAltGenericReceive	src/FreeRTOS_AVR/utility/queue.c	/^	BaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, BaseType_t xJustPeeking )$/;"	f
xQueueAltGenericSend	src/FreeRTOS_AVR/utility/mpu_wrappers.h	116;"	d
xQueueAltGenericSend	src/FreeRTOS_AVR/utility/queue.c	/^	BaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, BaseType_t xCopyPosition )$/;"	f
xQueueAltPeek	src/FreeRTOS_AVR/utility/queue.h	1460;"	d
xQueueAltReceive	src/FreeRTOS_AVR/utility/queue.h	1459;"	d
xQueueAltSendToBack	src/FreeRTOS_AVR/utility/queue.h	1458;"	d
xQueueAltSendToFront	src/FreeRTOS_AVR/utility/queue.h	1457;"	d
xQueueCRReceive	src/FreeRTOS_AVR/utility/queue.c	/^	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )$/;"	f
xQueueCRReceiveFromISR	src/FreeRTOS_AVR/utility/queue.c	/^	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )$/;"	f
xQueueCRSend	src/FreeRTOS_AVR/utility/queue.c	/^	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )$/;"	f
xQueueCRSendFromISR	src/FreeRTOS_AVR/utility/queue.c	/^	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )$/;"	f
xQueueCreate	src/FreeRTOS_AVR/utility/queue.h	173;"	d
xQueueCreateCountingSemaphore	src/FreeRTOS_AVR/utility/mpu_wrappers.h	114;"	d
xQueueCreateCountingSemaphore	src/FreeRTOS_AVR/utility/queue.c	/^	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )$/;"	f
xQueueCreateMutex	src/FreeRTOS_AVR/utility/mpu_wrappers.h	111;"	d
xQueueCreateMutex	src/FreeRTOS_AVR/utility/queue.c	/^	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )$/;"	f
xQueueCreateSet	src/FreeRTOS_AVR/utility/mpu_wrappers.h	122;"	d
xQueueCreateSet	src/FreeRTOS_AVR/utility/queue.c	/^	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )$/;"	f
xQueueGenericCreate	src/FreeRTOS_AVR/utility/mpu_wrappers.h	110;"	d
xQueueGenericCreate	src/FreeRTOS_AVR/utility/queue.c	/^QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )$/;"	f
xQueueGenericReceive	src/FreeRTOS_AVR/utility/mpu_wrappers.h	118;"	d
xQueueGenericReceive	src/FreeRTOS_AVR/utility/queue.c	/^BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )$/;"	f
xQueueGenericReset	src/FreeRTOS_AVR/utility/mpu_wrappers.h	121;"	d
xQueueGenericReset	src/FreeRTOS_AVR/utility/queue.c	/^BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )$/;"	f
xQueueGenericSend	src/FreeRTOS_AVR/utility/mpu_wrappers.h	115;"	d
xQueueGenericSend	src/FreeRTOS_AVR/utility/queue.c	/^BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )$/;"	f
xQueueGenericSendFromISR	src/FreeRTOS_AVR/utility/queue.c	/^BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )$/;"	f
xQueueGetMutexHolder	src/FreeRTOS_AVR/utility/mpu_wrappers.h	126;"	d
xQueueGetMutexHolder	src/FreeRTOS_AVR/utility/mpu_wrappers.h	127;"	d
xQueueGetMutexHolder	src/FreeRTOS_AVR/utility/queue.c	/^	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )$/;"	f
xQueueGiveFromISR	src/FreeRTOS_AVR/utility/queue.c	/^BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )$/;"	f
xQueueGiveMutexRecursive	src/FreeRTOS_AVR/utility/mpu_wrappers.h	112;"	d
xQueueGiveMutexRecursive	src/FreeRTOS_AVR/utility/queue.c	/^	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )$/;"	f
xQueueHandle	src/FreeRTOS_AVR/utility/FreeRTOS.h	801;"	d
xQueueIsQueueEmptyFromISR	src/FreeRTOS_AVR/utility/queue.c	/^BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )$/;"	f
xQueueIsQueueFullFromISR	src/FreeRTOS_AVR/utility/queue.c	/^BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )$/;"	f
xQueueOverwrite	src/FreeRTOS_AVR/utility/queue.h	504;"	d
xQueueOverwriteFromISR	src/FreeRTOS_AVR/utility/queue.h	1187;"	d
xQueuePeek	src/FreeRTOS_AVR/utility/queue.h	688;"	d
xQueuePeekFromISR	src/FreeRTOS_AVR/utility/queue.c	/^BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )$/;"	f
xQueueReceive	src/FreeRTOS_AVR/utility/queue.h	814;"	d
xQueueReceiveFromISR	src/FreeRTOS_AVR/utility/queue.c	/^BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )$/;"	f
xQueueRegistry	src/FreeRTOS_AVR/utility/queue.c	/^	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];$/;"	v
xQueueRegistryItem	src/FreeRTOS_AVR/utility/queue.c	/^	} xQueueRegistryItem;$/;"	t	typeref:struct:QUEUE_REGISTRY_ITEM	file:
xQueueRemoveFromSet	src/FreeRTOS_AVR/utility/mpu_wrappers.h	125;"	d
xQueueRemoveFromSet	src/FreeRTOS_AVR/utility/queue.c	/^	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )$/;"	f
xQueueReset	src/FreeRTOS_AVR/utility/queue.h	1496;"	d
xQueueSelectFromSet	src/FreeRTOS_AVR/utility/mpu_wrappers.h	123;"	d
xQueueSelectFromSet	src/FreeRTOS_AVR/utility/queue.c	/^	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )$/;"	f
xQueueSelectFromSetFromISR	src/FreeRTOS_AVR/utility/queue.c	/^	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )$/;"	f
xQueueSend	src/FreeRTOS_AVR/utility/queue.h	421;"	d
xQueueSendFromISR	src/FreeRTOS_AVR/utility/queue.h	1261;"	d
xQueueSendToBack	src/FreeRTOS_AVR/utility/queue.h	337;"	d
xQueueSendToBackFromISR	src/FreeRTOS_AVR/utility/queue.h	1100;"	d
xQueueSendToFront	src/FreeRTOS_AVR/utility/queue.h	255;"	d
xQueueSendToFrontFromISR	src/FreeRTOS_AVR/utility/queue.h	1029;"	d
xQueueSetHandle	src/FreeRTOS_AVR/utility/FreeRTOS.h	803;"	d
xQueueSetMemberHandle	src/FreeRTOS_AVR/utility/FreeRTOS.h	804;"	d
xQueueTakeMutexRecursive	src/FreeRTOS_AVR/utility/mpu_wrappers.h	113;"	d
xQueueTakeMutexRecursive	src/FreeRTOS_AVR/utility/queue.c	/^	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )$/;"	f
xRegions	src/FreeRTOS_AVR/utility/task.h	/^	MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];$/;"	m	struct:xTASK_PARAMETERS
xRxLock	src/FreeRTOS_AVR/utility/queue.c	/^	volatile BaseType_t xRxLock;	\/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. *\/$/;"	m	struct:QueueDefinition	file:
xSchedulerRunning	src/FreeRTOS_AVR/utility/tasks.c	/^PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;$/;"	v	file:
xSemaphoreAltGive	src/FreeRTOS_AVR/utility/semphr.h	521;"	d
xSemaphoreAltTake	src/FreeRTOS_AVR/utility/semphr.h	360;"	d
xSemaphoreCreateBinary	src/FreeRTOS_AVR/utility/semphr.h	185;"	d
xSemaphoreCreateCounting	src/FreeRTOS_AVR/utility/semphr.h	811;"	d
xSemaphoreCreateMutex	src/FreeRTOS_AVR/utility/semphr.h	693;"	d
xSemaphoreCreateRecursiveMutex	src/FreeRTOS_AVR/utility/semphr.h	748;"	d
xSemaphoreGetMutexHolder	src/FreeRTOS_AVR/utility/semphr.h	840;"	d
xSemaphoreGive	src/FreeRTOS_AVR/utility/semphr.h	423;"	d
xSemaphoreGiveFromISR	src/FreeRTOS_AVR/utility/semphr.h	612;"	d
xSemaphoreGiveRecursive	src/FreeRTOS_AVR/utility/semphr.h	507;"	d
xSemaphoreHandle	src/FreeRTOS_AVR/utility/FreeRTOS.h	802;"	d
xSemaphoreTake	src/FreeRTOS_AVR/utility/semphr.h	252;"	d
xSemaphoreTakeFromISR	src/FreeRTOS_AVR/utility/semphr.h	646;"	d
xSemaphoreTakeRecursive	src/FreeRTOS_AVR/utility/semphr.h	345;"	d
xSizeInBytes	src/FreeRTOS_AVR/utility/portable.h	/^	size_t xSizeInBytes;$/;"	m	struct:HeapRegion
xSuspendedTaskList	src/FreeRTOS_AVR/utility/tasks.c	/^	PRIVILEGED_DATA static List_t xSuspendedTaskList;					\/*< Tasks that are currently suspended. *\/$/;"	v	file:
xTASK_PARAMETERS	src/FreeRTOS_AVR/utility/task.h	/^typedef struct xTASK_PARAMETERS$/;"	s
xTASK_STATUS	src/FreeRTOS_AVR/utility/task.h	/^typedef struct xTASK_STATUS$/;"	s
xTIMER	src/FreeRTOS_AVR/utility/timers.c	/^} xTIMER;$/;"	t	typeref:struct:tmrTimerControl	file:
xTIME_OUT	src/FreeRTOS_AVR/utility/task.h	/^typedef struct xTIME_OUT$/;"	s
xTaskCallApplicationTaskHook	src/FreeRTOS_AVR/utility/mpu_wrappers.h	100;"	d
xTaskCallApplicationTaskHook	src/FreeRTOS_AVR/utility/tasks.c	/^	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )$/;"	f
xTaskCheckForTimeOut	src/FreeRTOS_AVR/utility/tasks.c	/^BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )$/;"	f
xTaskCreate	src/FreeRTOS_AVR/utility/task.h	345;"	d
xTaskCreateRestricted	src/FreeRTOS_AVR/utility/task.h	414;"	d
xTaskGenericCreate	src/FreeRTOS_AVR/utility/mpu_wrappers.h	82;"	d
xTaskGenericCreate	src/FreeRTOS_AVR/utility/tasks.c	/^BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f
xTaskGenericNotify	src/FreeRTOS_AVR/utility/mpu_wrappers.h	106;"	d
xTaskGenericNotify	src/FreeRTOS_AVR/utility/tasks.c	/^	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )$/;"	f
xTaskGenericNotifyFromISR	src/FreeRTOS_AVR/utility/tasks.c	/^	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )$/;"	f
xTaskGetApplicationTaskTag	src/FreeRTOS_AVR/utility/mpu_wrappers.h	99;"	d
xTaskGetApplicationTaskTag	src/FreeRTOS_AVR/utility/tasks.c	/^	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )$/;"	f
xTaskGetCurrentTaskHandle	src/FreeRTOS_AVR/utility/mpu_wrappers.h	102;"	d
xTaskGetCurrentTaskHandle	src/FreeRTOS_AVR/utility/tasks.c	/^	TaskHandle_t xTaskGetCurrentTaskHandle( void )$/;"	f
xTaskGetIdleTaskHandle	src/FreeRTOS_AVR/utility/mpu_wrappers.h	104;"	d
xTaskGetIdleTaskHandle	src/FreeRTOS_AVR/utility/tasks.c	/^	TaskHandle_t xTaskGetIdleTaskHandle( void )$/;"	f
xTaskGetSchedulerState	src/FreeRTOS_AVR/utility/mpu_wrappers.h	103;"	d
xTaskGetSchedulerState	src/FreeRTOS_AVR/utility/tasks.c	/^	BaseType_t xTaskGetSchedulerState( void )$/;"	f
xTaskGetTickCount	src/FreeRTOS_AVR/utility/mpu_wrappers.h	94;"	d
xTaskGetTickCount	src/FreeRTOS_AVR/utility/tasks.c	/^TickType_t xTaskGetTickCount( void )$/;"	f
xTaskGetTickCountFromISR	src/FreeRTOS_AVR/utility/tasks.c	/^TickType_t xTaskGetTickCountFromISR( void )$/;"	f
xTaskHandle	src/FreeRTOS_AVR/utility/FreeRTOS.h	800;"	d
xTaskIncrementTick	src/FreeRTOS_AVR/utility/tasks.c	/^BaseType_t xTaskIncrementTick( void )$/;"	f
xTaskNotify	src/FreeRTOS_AVR/utility/task.h	1476;"	d
xTaskNotifyAndQuery	src/FreeRTOS_AVR/utility/task.h	1477;"	d
xTaskNotifyAndQueryFromISR	src/FreeRTOS_AVR/utility/task.h	1568;"	d
xTaskNotifyFromISR	src/FreeRTOS_AVR/utility/task.h	1567;"	d
xTaskNotifyGive	src/FreeRTOS_AVR/utility/task.h	1689;"	d
xTaskNotifyStateClear	src/FreeRTOS_AVR/utility/tasks.c	/^	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )$/;"	f
xTaskNotifyWait	src/FreeRTOS_AVR/utility/mpu_wrappers.h	107;"	d
xTaskNotifyWait	src/FreeRTOS_AVR/utility/tasks.c	/^	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )$/;"	f
xTaskNumber	src/FreeRTOS_AVR/utility/task.h	/^	UBaseType_t xTaskNumber;		\/* A number unique to the task. *\/$/;"	m	struct:xTASK_STATUS
xTaskParameters	src/FreeRTOS_AVR/utility/FreeRTOS.h	807;"	d
xTaskPriorityDisinherit	src/FreeRTOS_AVR/utility/tasks.c	/^	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )$/;"	f
xTaskRemoveFromEventList	src/FreeRTOS_AVR/utility/tasks.c	/^BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )$/;"	f
xTaskRemoveFromUnorderedEventList	src/FreeRTOS_AVR/utility/tasks.c	/^BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )$/;"	f
xTaskResumeAll	src/FreeRTOS_AVR/utility/mpu_wrappers.h	93;"	d
xTaskResumeAll	src/FreeRTOS_AVR/utility/tasks.c	/^BaseType_t xTaskResumeAll( void )$/;"	f
xTaskResumeFromISR	src/FreeRTOS_AVR/utility/tasks.c	/^	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )$/;"	f
xTaskStatusType	src/FreeRTOS_AVR/utility/FreeRTOS.h	808;"	d
xTasksWaitingForBits	src/FreeRTOS_AVR/utility/event_groups.c	/^	List_t xTasksWaitingForBits;		\/*< List of tasks waiting for a bit to be set. *\/$/;"	m	struct:xEventGroupDefinition	file:
xTasksWaitingTermination	src/FreeRTOS_AVR/utility/tasks.c	/^	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				\/*< Tasks that have been deleted - but their memory not yet freed. *\/$/;"	v	file:
xTasksWaitingToReceive	src/FreeRTOS_AVR/utility/queue.c	/^	List_t xTasksWaitingToReceive;	\/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. *\/$/;"	m	struct:QueueDefinition	file:
xTasksWaitingToSend	src/FreeRTOS_AVR/utility/queue.c	/^	List_t xTasksWaitingToSend;		\/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. *\/$/;"	m	struct:QueueDefinition	file:
xTickCount	src/FreeRTOS_AVR/utility/tasks.c	/^PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;$/;"	v	file:
xTimeOnEntering	src/FreeRTOS_AVR/utility/task.h	/^	TickType_t xTimeOnEntering;$/;"	m	struct:xTIME_OUT
xTimeOutType	src/FreeRTOS_AVR/utility/FreeRTOS.h	805;"	d
xTimerChangePeriod	src/FreeRTOS_AVR/utility/timers.h	525;"	d
xTimerChangePeriodFromISR	src/FreeRTOS_AVR/utility/timers.h	909;"	d
xTimerCreate	src/FreeRTOS_AVR/utility/mpu_wrappers.h	140;"	d
xTimerCreate	src/FreeRTOS_AVR/utility/timers.c	/^TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f
xTimerCreateTimerTask	src/FreeRTOS_AVR/utility/timers.c	/^BaseType_t xTimerCreateTimerTask( void )$/;"	f
xTimerDelete	src/FreeRTOS_AVR/utility/timers.h	563;"	d
xTimerGenericCommand	src/FreeRTOS_AVR/utility/mpu_wrappers.h	147;"	d
xTimerGenericCommand	src/FreeRTOS_AVR/utility/timers.c	/^BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )$/;"	f
xTimerGetTimerDaemonTaskHandle	src/FreeRTOS_AVR/utility/mpu_wrappers.h	144;"	d
xTimerGetTimerDaemonTaskHandle	src/FreeRTOS_AVR/utility/timers.c	/^	TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )$/;"	f
xTimerHandle	src/FreeRTOS_AVR/utility/FreeRTOS.h	809;"	d
xTimerIsTimerActive	src/FreeRTOS_AVR/utility/mpu_wrappers.h	143;"	d
xTimerIsTimerActive	src/FreeRTOS_AVR/utility/timers.c	/^BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )$/;"	f
xTimerListItem	src/FreeRTOS_AVR/utility/timers.c	/^	ListItem_t				xTimerListItem;		\/*<< Standard linked list item as used by all kernel features for event management. *\/$/;"	m	struct:tmrTimerControl	file:
xTimerParameters	src/FreeRTOS_AVR/utility/timers.c	/^		TimerParameter_t xTimerParameters;$/;"	m	union:tmrTimerQueueMessage::__anon1	file:
xTimerPendFunctionCall	src/FreeRTOS_AVR/utility/mpu_wrappers.h	145;"	d
xTimerPendFunctionCall	src/FreeRTOS_AVR/utility/timers.c	/^	BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )$/;"	f
xTimerPendFunctionCallFromISR	src/FreeRTOS_AVR/utility/timers.c	/^	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )$/;"	f
xTimerPeriodInTicks	src/FreeRTOS_AVR/utility/timers.c	/^	TickType_t				xTimerPeriodInTicks;\/*<< How quickly and often the timer expires. *\/$/;"	m	struct:tmrTimerControl	file:
xTimerQueue	src/FreeRTOS_AVR/utility/timers.c	/^PRIVILEGED_DATA static QueueHandle_t xTimerQueue = NULL;$/;"	v	file:
xTimerReset	src/FreeRTOS_AVR/utility/timers.h	687;"	d
xTimerResetFromISR	src/FreeRTOS_AVR/utility/timers.h	995;"	d
xTimerStart	src/FreeRTOS_AVR/utility/timers.h	403;"	d
xTimerStartFromISR	src/FreeRTOS_AVR/utility/timers.h	773;"	d
xTimerStop	src/FreeRTOS_AVR/utility/timers.h	445;"	d
xTimerStopFromISR	src/FreeRTOS_AVR/utility/timers.h	836;"	d
xTimerTaskHandle	src/FreeRTOS_AVR/utility/timers.c	/^	PRIVILEGED_DATA static TaskHandle_t xTimerTaskHandle = NULL;$/;"	v	file:
xTxLock	src/FreeRTOS_AVR/utility/queue.c	/^	volatile BaseType_t xTxLock;	\/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. *\/$/;"	m	struct:QueueDefinition	file:
xUsingStaticallyAllocatedStack	src/FreeRTOS_AVR/utility/tasks.c	/^		BaseType_t		xUsingStaticallyAllocatedStack; \/* Set to pdTRUE if the stack is a statically allocated array, and pdFALSE if the stack is dynamically allocated. *\/$/;"	m	struct:tskTaskControlBlock	file:
xYieldPending	src/FreeRTOS_AVR/utility/tasks.c	/^PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;$/;"	v	file:
